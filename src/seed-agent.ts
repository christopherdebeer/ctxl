/**
 * Contextual agent seed â€” objective-first, context-building, self-composing.
 *
 * Split into its own file because the template is large.
 * Exported as a string and consumed by seeds.ts.
 */

// Build the agent source as an array of lines joined at export time.
// This avoids nested template literal escaping issues.
const L: string[] = [];
const o = (s: string) => L.push(s);

o('import React, { useState, useRef, useEffect, useCallback } from "react";');
o('import styled from "styled-components";');
o('import type { AgentProps } from "./agent-mount";');
o('');
o('const Container = styled.div`height:100%;display:flex;flex-direction:column;font-family:ui-sans-serif,system-ui,-apple-system,sans-serif;background:#fafafa;`;');
o('const Hero = styled.div`flex:1;display:flex;flex-direction:column;align-items:center;justify-content:center;padding:32px;text-align:center;`;');
o('const Title = styled.h1`font-size:2rem;font-weight:200;margin:0 0 8px;background:linear-gradient(135deg,#667eea 0%,#764ba2 100%);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text;`;');
o('const Subtitle = styled.p`color:#999;margin:0 0 40px;font-size:14px;font-weight:300;`;');
o('const PromptGrid = styled.div`display:flex;flex-wrap:wrap;gap:10px;justify-content:center;max-width:520px;margin-bottom:32px;`;');
o('const PromptChip = styled.button`padding:10px 20px;font-size:14px;font-weight:400;border:1.5px solid #e0e0e0;border-radius:999px;background:#fff;color:#444;cursor:pointer;transition:all 0.2s ease;font-family:inherit;&:hover{border-color:#667eea;color:#667eea;background:#f8f7ff;transform:translateY(-1px);box-shadow:0 2px 8px rgba(102,126,234,0.15);}&:disabled{opacity:0.5;cursor:not-allowed;transform:none;}`;');
o('const ObjectiveInput = styled.input`width:100%;max-width:480px;padding:14px 20px;font-size:15px;border:2px solid #e0e0e0;border-radius:14px;outline:none;font-family:inherit;background:#fff;transition:border-color 0.2s;&:focus{border-color:#667eea;box-shadow:0 0 0 3px rgba(102,126,234,0.1);}&::placeholder{color:#bbb;}`;');
o('const WorkspaceContainer = styled.div`flex:1;display:flex;flex-direction:column;overflow:hidden;`;');
o('const WorkspaceHeader = styled.div`padding:16px 24px;border-bottom:1px solid #eee;background:#fff;display:flex;align-items:center;gap:12px;`;');
o('const ObjectiveLabel = styled.div`flex:1;font-size:15px;font-weight:500;color:#333;`;');
o('const SmallBtn = styled.button<{$variant?:string}>`padding:6px 14px;font-size:12px;font-weight:500;border:1px solid ${(p:any)=>p.$variant==="primary"?"#667eea":"#ddd"};border-radius:8px;background:${(p:any)=>p.$variant==="primary"?"linear-gradient(135deg,#667eea 0%,#764ba2 100%)":"#fff"};color:${(p:any)=>p.$variant==="primary"?"#fff":"#555"};cursor:pointer;font-family:inherit;transition:all 0.15s;&:hover:not(:disabled){transform:translateY(-1px);}&:disabled{opacity:0.5;cursor:not-allowed;transform:none;}`;');
o('const TasksArea = styled.div`flex:1;overflow-y:auto;padding:20px 24px;display:flex;flex-direction:column;gap:12px;`;');
o('const TaskCard = styled.div<{$status?:string}>`padding:16px;border-radius:12px;border:1.5px solid ${(p:any)=>p.$status==="active"?"#667eea":p.$status==="composed"?"#4caf50":"#e8e8e8"};background:${(p:any)=>p.$status==="active"?"#f8f7ff":p.$status==="composed"?"#f5fff5":"#fff"};transition:all 0.2s;`;');
o('const TaskTitle = styled.div`font-weight:500;font-size:14px;margin-bottom:4px;color:#333;`;');
o('const TaskDesc = styled.div`font-size:13px;color:#777;line-height:1.5;`;');
o('const TaskMeta = styled.div`display:flex;gap:8px;margin-top:10px;flex-wrap:wrap;`;');
o('const Tag = styled.span<{$color?:string}>`padding:2px 8px;font-size:11px;border-radius:999px;border:1px solid ${(p:any)=>p.$color||"#ddd"};color:${(p:any)=>p.$color||"#888"};`;');
o('const ConversationArea = styled.div`border-top:1px solid #eee;padding:12px 24px;background:#fff;display:flex;gap:8px;align-items:center;`;');
o('const ConvInput = styled.input`flex:1;padding:10px 14px;font-size:14px;border:2px solid #e0e0e0;border-radius:10px;outline:none;font-family:inherit;&:focus{border-color:#667eea;}`;');
o('const StatusBar = styled.div`padding:8px 24px;font-size:12px;color:#667eea;font-style:italic;border-top:1px solid #f0f0f0;background:#fefefe;`;');
o('');
o('interface Task {');
o('  id: string; title: string; description: string;');
o('  inputs: string[]; outputs: string[]; measures: string[];');
o('  status: "proposed"|"accepted"|"active"|"composed"|"dismissed";');
o('  composedPath?: string;');
o('}');
o('');
o('interface ContextState {');
o('  objective: string;');
o('  phase: "intro"|"building"|"workspace";');
o('  tasks: Task[];');
o('  messages: Array<{role:"user"|"agent"|"system";content:string}>;');
o('}');
o('');
o('const introPrompts = ["Make a tool","Get something done","Have some fun","Explore","Experiment","Learn something"];');
o('');
o('export default function Agent({ state, act, self }: AgentProps) {');
o('  const [ctx, setCtx] = useState<ContextState>(() => ({');
o('    objective: state._objective || "",');
o('    phase: state._objective ? "workspace" : "intro",');
o('    tasks: state._tasks || [],');
o('    messages: state._messages || [],');
o('  }));');
o('  const [input, setInput] = useState("");');
o('  const inputRef = useRef<HTMLInputElement>(null);');
o('  const messagesEnd = useRef<HTMLDivElement>(null);');
o('');
o('  useEffect(() => {');
o('    if (ctx.phase !== "intro") {');
o('      act({ _objective: ctx.objective, _tasks: ctx.tasks, _messages: ctx.messages, _phase: ctx.phase });');
o('    }');
o('  }, [ctx.objective, ctx.tasks, ctx.messages, ctx.phase]);');
o('');
o('  useEffect(() => { messagesEnd.current?.scrollIntoView({ behavior: "smooth" }); }, [ctx.messages]);');
o('');
o('  const handlePromptSelect = useCallback(async (prompt: string) => {');
o('    const objective = prompt === "custom" ? input.trim() : prompt;');
o('    if (!objective) return;');
o('    setCtx(prev => ({ ...prev, objective, phase: "building" as const, messages: [{ role: "user" as const, content: objective }] }));');
o('    const thinkPrompt = "The user\'s objective is: \\"" + objective + "\\"\\n\\nDecompose this into 2-4 concrete tasks. For each task identify: a clear title, a brief description, input data needed (list of strings), output data produced (list of strings), how to measure success (list of evaluation criteria).\\n\\nRespond with JSON:\\n{\\n  \\"content\\": \\"Your friendly response\\",\\n  \\"structured\\": { \\"tasks\\": [{ \\"id\\": \\"task-1\\", \\"title\\": \\"...\\", \\"description\\": \\"...\\", \\"inputs\\": [\\"...\\"], \\"outputs\\": [\\"...\\"], \\"measures\\": [\\"...\\"], \\"status\\": \\"proposed\\" }] },\\n  \\"shouldEvolve\\": false\\n}";');
o('    const result = await self.think(thinkPrompt, ctx.messages);');
o('    const tasks: Task[] = result.structured?.tasks || [];');
o('    const agentMessage = result.content || "Let me think about how to approach this...";');
o('    setCtx(prev => ({ ...prev, phase: "workspace" as const, tasks: tasks.length > 0 ? tasks : prev.tasks, messages: [...prev.messages, { role: "agent" as const, content: agentMessage }] }));');
o('  }, [input, self]);');
o('');
o('  const handleAcceptTask = useCallback((taskId: string) => {');
o('    setCtx(prev => ({ ...prev, tasks: prev.tasks.map(t => t.id === taskId ? { ...t, status: "accepted" as const } : t) }));');
o('  }, []);');
o('');
o('  const handleDismissTask = useCallback((taskId: string) => {');
o('    setCtx(prev => ({ ...prev, tasks: prev.tasks.map(t => t.id === taskId ? { ...t, status: "dismissed" as const } : t) }));');
o('  }, []);');
o('');
o('  const handleComposeTask = useCallback(async (task: Task) => {');
o('    const safeName = task.id.replace(/[^a-zA-Z0-9-]/g, "-");');
o('    const path = "/src/tasks/" + safeName + ".tsx";');
o('    setCtx(prev => ({');
o('      ...prev,');
o('      tasks: prev.tasks.map(t => t.id === task.id ? { ...t, status: "active" as const } : t),');
o('      messages: [...prev.messages, { role: "system" as const, content: "Composing: " + task.title + "..." }],');
o('    }));');
o('    const purpose = "Task: " + task.title + "\\nDescription: " + task.description + "\\nInputs: " + task.inputs.join(", ") + "\\nOutputs: " + task.outputs.join(", ") + "\\nMeasures: " + task.measures.join(", ") + "\\n\\nCreate a React component that implements this task. Accept props for inputs and render outputs. If the task benefits from LLM reasoning, use useAgentSelf to make it agentic. Include appropriate UI affordances.";');
o('    const result = await self.compose(path, purpose);');
o('    if (result.error) {');
o('      setCtx(prev => ({');
o('        ...prev,');
o('        tasks: prev.tasks.map(t => t.id === task.id ? { ...t, status: "accepted" as const } : t),');
o('        messages: [...prev.messages, { role: "system" as const, content: "Compose error: " + result.error }],');
o('      }));');
o('    } else {');
o('      setCtx(prev => ({');
o('        ...prev,');
o('        tasks: prev.tasks.map(t => t.id === task.id ? { ...t, status: "composed" as const, composedPath: path } : t),');
o('        messages: [...prev.messages, { role: "agent" as const, content: task.title + " is ready at " + path }],');
o('      }));');
o('      // Evolve to integrate the composed component');
o('      const allComposed = [...ctx.tasks.filter(t => t.status === "composed"), { ...task, composedPath: path }];');
o('      const taskList = allComposed.map(t => "  " + (t.composedPath || path) + " (" + t.title + ")").join("\\n");');
o('      await self.evolve("New task component composed at " + path + " for \\"" + task.title + "\\".\\nAll composed tasks:\\n" + taskList + "\\n\\nEvolve to: import composed task components dynamically, render them in the workspace alongside task cards, keep ALL existing functionality (intro flow, task cards, conversation, compose buttons). Use React.lazy and Suspense for dynamic imports.");');
o('    }');
o('  }, [ctx.tasks, self]);');
o('');
o('  const handleConversation = useCallback(async () => {');
o('    const query = input.trim();');
o('    if (!query || self.isThinking || self.isEvolving) return;');
o('    setInput("");');
o('    setCtx(prev => ({ ...prev, messages: [...prev.messages, { role: "user" as const, content: query }] }));');
o('    const result = await self.think(query, ctx.messages);');
o('    if (result.content) {');
o('      setCtx(prev => ({ ...prev, messages: [...prev.messages, { role: "agent" as const, content: result.content! }] }));');
o('    }');
o('    if (result.structured?.tasks) {');
o('      setCtx(prev => ({ ...prev, tasks: [...prev.tasks, ...result.structured.tasks] }));');
o('    }');
o('    if (result.actions) { for (const action of result.actions) act(action); }');
o('    if (result.shouldEvolve && result.evolveReason) {');
o('      setCtx(prev => ({ ...prev, messages: [...prev.messages, { role: "system" as const, content: "Evolving: " + result.evolveReason }] }));');
o('      await self.evolve(result.evolveReason!);');
o('    }');
o('  }, [input, self, act]);');
o('');
o('  const handleReset = useCallback(() => {');
o('    setCtx({ objective: "", phase: "intro", tasks: [], messages: [] });');
o('    act({ _objective: "", _tasks: [], _messages: [], _phase: "intro" });');
o('  }, [act]);');
o('');
o('  const busy = self.isThinking || self.isEvolving;');
o('  const visibleTasks = ctx.tasks.filter(t => t.status !== "dismissed");');
o('');
o('  // ---- Intro Phase ----');
o('  if (ctx.phase === "intro") {');
o('    return (');
o('      <Container>');
o('        <Hero>');
o('          <Title>Contextual</Title>');
o('          <Subtitle>A tool for making tools</Subtitle>');
o('          <PromptGrid>');
o('            {introPrompts.map(p => (');
o('              <PromptChip key={p} onClick={() => handlePromptSelect(p)} disabled={busy}>{p}</PromptChip>');
o('            ))}');
o('          </PromptGrid>');
o('          <ObjectiveInput');
o('            ref={inputRef}');
o('            value={input}');
o('            onChange={e => setInput(e.target.value)}');
o('            onKeyDown={e => { if (e.key === "Enter") handlePromptSelect("custom"); }}');
o('            placeholder="Or describe what you want to build..."');
o('            disabled={busy}');
o('          />');
o('        </Hero>');
o('      </Container>');
o('    );');
o('  }');
o('');
o('  // ---- Building Phase (spinner) ----');
o('  if (ctx.phase === "building") {');
o('    return (');
o('      <Container>');
o('        <Hero>');
o('          <Title>Contextual</Title>');
o('          <Subtitle>Thinking about: {ctx.objective}</Subtitle>');
o('          <StatusBar>Decomposing objective into tasks...</StatusBar>');
o('        </Hero>');
o('      </Container>');
o('    );');
o('  }');
o('');
o('  // ---- Workspace Phase ----');
o('  return (');
o('    <Container>');
o('      <WorkspaceContainer>');
o('        <WorkspaceHeader>');
o('          <ObjectiveLabel>{ctx.objective}</ObjectiveLabel>');
o('          <SmallBtn onClick={handleReset}>New Objective</SmallBtn>');
o('        </WorkspaceHeader>');
o('        <TasksArea>');
o('          {visibleTasks.map(task => (');
o('            <TaskCard key={task.id} $status={task.status}>');
o('              <TaskTitle>{task.title}</TaskTitle>');
o('              <TaskDesc>{task.description}</TaskDesc>');
o('              <TaskMeta>');
o('                {task.inputs.map((inp, i) => <Tag key={"i"+i} $color="#667eea">{inp}</Tag>)}');
o('                {task.outputs.map((out, i) => <Tag key={"o"+i} $color="#4caf50">{out}</Tag>)}');
o('                {task.measures.map((m, i) => <Tag key={"m"+i} $color="#ff9800">{m}</Tag>)}');
o('              </TaskMeta>');
o('              <TaskMeta>');
o('                {task.status === "proposed" && (');
o('                  <>');
o('                    <SmallBtn $variant="primary" onClick={() => handleAcceptTask(task.id)}>Accept</SmallBtn>');
o('                    <SmallBtn onClick={() => handleDismissTask(task.id)}>Dismiss</SmallBtn>');
o('                  </>');
o('                )}');
o('                {task.status === "accepted" && (');
o('                  <SmallBtn $variant="primary" onClick={() => handleComposeTask(task)} disabled={busy}>');
o('                    {busy ? "Working..." : "Compose"}');
o('                  </SmallBtn>');
o('                )}');
o('                {task.status === "active" && <Tag $color="#667eea">Composing...</Tag>}');
o('                {task.status === "composed" && <Tag $color="#4caf50">Ready</Tag>}');
o('              </TaskMeta>');
o('            </TaskCard>');
o('          ))}');
o('          {ctx.messages.length > 0 && (');
o('            <div style={{ marginTop: 8 }}>');
o('              {ctx.messages.slice(-5).map((msg, i) => (');
o('                <div key={i} style={{');
o('                  padding: "6px 0", fontSize: 13, lineHeight: 1.5,');
o('                  color: msg.role === "user" ? "#667eea" : msg.role === "system" ? "#999" : "#333",');
o('                }}>');
o('                  <strong>{msg.role === "user" ? "You" : msg.role === "agent" ? "Agent" : "System"}:</strong> {msg.content}');
o('                </div>');
o('              ))}');
o('              <div ref={messagesEnd} />');
o('            </div>');
o('          )}');
o('        </TasksArea>');
o('        <ConversationArea>');
o('          <ConvInput');
o('            value={input}');
o('            onChange={e => setInput(e.target.value)}');
o('            onKeyDown={e => { if (e.key === "Enter") handleConversation(); }}');
o('            placeholder={busy ? "Working..." : "Refine tasks, ask questions, or add context..."}');
o('            disabled={busy}');
o('          />');
o('          <SmallBtn $variant="primary" onClick={handleConversation} disabled={busy || !input.trim()}>Send</SmallBtn>');
o('        </ConversationArea>');
o('      </WorkspaceContainer>');
o('      {busy && <StatusBar>{self.isThinking ? "Thinking..." : "Evolving..."}</StatusBar>}');
o('    </Container>');
o('  );');
o('}');

export const SEED_AGENT_SOURCE = L.join("\n");