/**
 * Seed: /src/useAgentState.ts — State hooks and self-composition.
 *
 * Provides:
 * - useAgentState() — subscribe to external persistent state
 * - useAgentMeta() — access mutation/think history
 * - useAgentSelf(path) — scoped agency for any component
 */

const L: string[] = [];
const o = (s: string) => L.push(s);

o('import React, { useSyncExternalStore, useCallback, useState, useMemo } from "react";');
o('');
o('type AgentMemory = Record<string, any>;');
o('');
o('export function useAgentState<T extends AgentMemory = AgentMemory>(): [T, (patch: Partial<T>) => void] {');
o('  const memory = useSyncExternalStore(');
o('    (cb) => window.__AGENT_STATE__.subscribe(cb),');
o('    () => window.__AGENT_STATE__.get()');
o('  ) as T;');
o('  const setMemory = useCallback((patch: Partial<T>) => {');
o('    window.__AGENT_STATE__.set(patch);');
o('  }, []);');
o('  return [memory, setMemory];');
o('}');
o('');
o('export function useAgentMeta() {');
o('  return window.__AGENT_STATE__.meta;');
o('}');
o('');
o('// ---- Self-composition: any component can become agentic ----');
o('');
o('export interface ThinkResult {');
o('  content?: string;');
o('  actions?: Record<string, any>[];');
o('  structured?: any;');
o('  shouldEvolve?: boolean;');
o('  evolveReason?: string;');
o('}');
o('');
o('export interface ComposeResult {');
o('  error: string | null;');
o('  source: string | null;');
o('  path: string;');
o('}');
o('');
o('export interface ConversationMessage {');
o('  role: "user" | "agent" | "system";');
o('  content: string;');
o('}');
o('');
o('export interface AgentSelf {');
o('  source: string;');
o('  path: string;');
o('  think: (prompt: string, history?: ConversationMessage[]) => Promise<ThinkResult>;');
o('  evolve: (prompt: string) => Promise<string>;');
o('  compose: (path: string, purpose: string) => Promise<ComposeResult>;');
o('  mutate: (newSource: string, reason?: string) => Promise<void>;');
o('  isThinking: boolean;');
o('  isEvolving: boolean;');
o('}');
o('');
o('/**');
o(' * useAgentSelf — gives any component its own scoped agency.');
o(' *');
o(' * Usage:');
o(' *   const self = useAgentSelf("/src/tasks/my-task.tsx");');
o(' *   // self.think(), self.evolve(), self.compose(), self.source');
o(' */');
o('export function useAgentSelf(filePath: string): AgentSelf {');
o('  const meta = useAgentMeta();');
o('  const [, act] = useAgentState();');
o('  const [isThinking, setIsThinking] = useState(false);');
o('  const [isEvolving, setIsEvolving] = useState(false);');
o('');
o('  const self: AgentSelf = useMemo(() => ({');
o('    get source() { return window.__RUNTIME__.files.get(filePath) ?? ""; },');
o('    path: filePath,');
o('    get isThinking() { return isThinking; },');
o('    get isEvolving() { return isEvolving; },');
o('');
o('    think: async (prompt: string, history?: ConversationMessage[]): Promise<ThinkResult> => {');
o('      setIsThinking(true);');
o('      meta.cycle++;');
o('      try {');
o('        const result = await window.__RUNTIME__.think(prompt, filePath, history);');
o('        meta.thinkHistory.push({ timestamp: Date.now(), prompt, result });');
o('        return result;');
o('      } catch (err: any) {');
o('        return { content: "Think error: " + (err?.message || String(err)) };');
o('      } finally { setIsThinking(false); }');
o('    },');
o('');
o('    evolve: async (prompt: string): Promise<string> => {');
o('      setIsEvolving(true);');
o('      meta.cycle++;');
o('      try {');
o('        const { error, content } = await window.__RUNTIME__.evolve(prompt, filePath);');
o('        if (error) { act({ _evolveError: error }); return ""; }');
o('        if (content && content.trim().startsWith("import ")) {');
o('          meta.mutations.push({ timestamp: Date.now(), reason: prompt, path: filePath });');
o('          try {');
o('            await window.__RUNTIME__.applyPatch([{ path: filePath, text: content, reason: prompt }]);');
o('          } catch (buildErr: any) {');
o('            act({ _evolveError: "Build failed: " + (buildErr.message || String(buildErr)) });');
o('            return "";');
o('          }');
o('        }');
o('        return content || "";');
o('      } finally { setIsEvolving(false); }');
o('    },');
o('');
o('    compose: async (path: string, purpose: string): Promise<ComposeResult> => {');
o('      meta.cycle++;');
o('      try {');
o('        const result = await window.__RUNTIME__.compose(path, purpose, filePath);');
o('        if (!result.error) {');
o('          meta.mutations.push({ timestamp: Date.now(), reason: "compose: " + purpose, path });');
o('        }');
o('        return result;');
o('      } catch (err: any) {');
o('        return { error: err.message || String(err), source: null, path };');
o('      }');
o('    },');
o('');
o('    mutate: async (newSource: string, reason?: string) => {');
o('      meta.mutations.push({ timestamp: Date.now(), reason: reason ?? "self-mutation", path: filePath });');
o('      await window.__RUNTIME__.applyPatch([{ path: filePath, text: newSource, reason }]);');
o('    },');
o('  }), [filePath, meta, isThinking, isEvolving]);');
o('');
o('  return self;');
o('}');

export const SEED_USE_AGENT_STATE_SOURCE = L.join("\n");