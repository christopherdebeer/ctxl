<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>100% clientside TSX hot reload (esbuild-wasm + React)</title>

    <!-- Import map so our Blob-ESM bundle can resolve bare imports like "react" -->
    <script type="importmap">
      {
        "imports": {
          "react": "https://esm.sh/react@18.3.1",
          "react/jsx-runtime": "https://esm.sh/react@18.3.1/jsx-runtime",
          "react-dom/client": "https://esm.sh/react-dom@18.3.1/client",
          "react-refresh/runtime": "https://esm.sh/react-refresh@0.14.2/runtime",
          "styled-components": "https://esm.sh/styled-components@6?deps=react@18.3.1,react-dom@18.3.1&external=react,react-dom"
        }
      }
    </script>

    <style>
      html, body { height: 100%; margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial; }

      /* Agent-first layout: preview takes full viewport */
      #shell { display: grid; grid-template-columns: 1fr; grid-template-rows: 1fr; height: 100%; }

      /* Dev drawer - hidden by default, slides in from left */
      #left {
        position: fixed;
        left: 0; top: 0; bottom: 0;
        width: 50vw;
        transform: translateX(-100%);
        transition: transform 0.2s ease;
        z-index: 100;
        background: #fff;
        box-shadow: 2px 0 10px rgba(0,0,0,0.1);
        display: grid;
        grid-template-rows: auto auto 1fr auto;
      }
      #left.open { transform: translateX(0); }

      /* Backdrop overlay when drawer is open */
      #drawerBackdrop {
        display: none;
        position: fixed;
        inset: 0;
        background: rgba(0,0,0,0.3);
        z-index: 99;
      }
      #drawerBackdrop.visible { display: block; }

      #toolbar { display: flex; gap: 8px; align-items: center; padding: 10px; border-bottom: 1px solid #eee; }
      #status { padding: 8px 10px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono"; font-size: 12px; border-bottom: 1px solid #eee; white-space: pre-wrap; }
      #editor { width: 100%; height: 100%; border: 0; resize: none; padding: 10px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono"; font-size: 12px; line-height: 1.4; outline: none; box-sizing: border-box; }
      #files { padding: 8px 10px; border-top: 1px solid #eee; display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
      #files button { font-family: ui-monospace, monospace; font-size: 12px; padding: 6px 8px; border: 1px solid #ddd; background: #fff; cursor: pointer; border-radius: 6px; }
      #files button[data-active="true"] { border-color: #000; }

      /* Preview takes full space */
      #right { display: grid; grid-template-rows: auto 1fr; height: 100%; }
      #previewTop { padding: 10px; border-bottom: 1px solid #eee; display: flex; gap: 8px; align-items: center; }
      #preview { height: 100%; }
      #root { height: 100%; }

      .pill { font-size: 12px; padding: 2px 8px; border: 1px solid #ddd; border-radius: 999px; }
      .warn { border-color: #f0c36d; background: #fff7e6; }
      .err  { border-color: #ff9a9a; background: #fff0f0; }

      /* Dev toggle button */
      #devToggle {
        padding: 6px 12px;
        border: 1px solid #ddd;
        border-radius: 6px;
        background: #fff;
        cursor: pointer;
        font-size: 13px;
        font-weight: 500;
        display: flex;
        align-items: center;
        gap: 6px;
        transition: background 0.15s, border-color 0.15s;
      }
      #devToggle:hover { background: #f5f5f5; border-color: #ccc; }
      #devToggle.active { background: #f0f0f0; border-color: #999; }

      /* Unsaved indicator dot */
      #devToggle .indicator {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        display: none;
      }
      #devToggle.unsaved .indicator {
        display: block;
        background: #f0c36d;
      }
      #devToggle.building .indicator {
        display: block;
        background: #667eea;
        animation: pulse 1s infinite;
      }
      @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.4; }
      }

      /* Mobile viewport */
      @media (max-width: 768px) {
        /* Drawer covers full width on mobile */
        #left {
          width: 100vw;
        }
        #toolbar { flex-wrap: wrap; }
        #toolbar button { min-height: 44px; min-width: 44px; padding: 10px 16px; }
        #files { overflow-x: auto; flex-wrap: nowrap; -webkit-overflow-scrolling: touch; }
        #files button { min-height: 44px; flex-shrink: 0; }
        #editor { min-height: 200px; }
        #previewTop { flex-wrap: wrap; }
        #devToggle { min-height: 44px; min-width: 44px; }
      }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/eruda"></script>

  </head>
  <body>
    <script>eruda.init();</script>
    <div id="shell">
      <!-- Backdrop for drawer -->
      <div id="drawerBackdrop"></div>

      <!-- Dev drawer (hidden by default) -->
      <div id="left">
        <div id="toolbar">
          <strong>VFS</strong>
          <span class="pill" id="modePill">idle</span>
          <button id="runBtn">Build & Run</button>
          <button id="resetBtn">Reset</button>
          <span style="opacity:.7;font-size:12px">Ctrl/Cmd+S builds</span>
        </div>
        <div id="status"></div>
        <textarea id="editor" spellcheck="false"></textarea>
        <div id="files"></div>
      </div>

      <!-- Agent preview (full viewport) -->
      <div id="right">
        <div id="previewTop">
          <button id="devToggle">Dev<span class="indicator"></span></button>
          <span class="pill" id="refreshPill">React Refresh loading…</span>
          <span class="pill" id="blobPill">Blob-ESM</span>
        </div>
        <div id="preview">
          <div id="root"></div>
        </div>
      </div>
    </div>

    <!-- esbuild-wasm from CDN -->
    <script type="module">
      import * as esbuild from "https://unpkg.com/esbuild-wasm@0.24.2/esm/browser.min.js";

      // -----------------------------
      // Tiny IndexedDB helper
      // -----------------------------
      const DB_NAME = "vfs_hmr_demo";
      const STORE = "files";

      function openDB() {
        console.debug("[dbg:idb] openDB called");
        return new Promise((resolve, reject) => {
          const req = indexedDB.open(DB_NAME, 1);
          req.onupgradeneeded = () => {
            console.debug("[dbg:idb] onupgradeneeded — creating object store");
            const db = req.result;
            if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE, { keyPath: "path" });
          };
          req.onsuccess = () => { console.debug("[dbg:idb] openDB success"); resolve(req.result); };
          req.onerror = () => { console.error("[dbg:idb] openDB error", req.error); reject(req.error); };
        });
      }

      async function dbGetAll() {
        console.debug("[dbg:idb] dbGetAll called");
        const db = await openDB();
        return new Promise((resolve, reject) => {
          const tx = db.transaction(STORE, "readonly");
          const os = tx.objectStore(STORE);
          const req = os.getAll();
          req.onsuccess = () => { console.debug("[dbg:idb] dbGetAll →", req.result?.length, "rows"); resolve(req.result || []); };
          req.onerror = () => { console.error("[dbg:idb] dbGetAll error", req.error); reject(req.error); };
        });
      }

      async function dbPut(path, text) {
        console.debug("[dbg:idb] dbPut", path, `(${text.length} chars)`);
        const db = await openDB();
        return new Promise((resolve, reject) => {
          const tx = db.transaction(STORE, "readwrite");
          tx.oncomplete = () => { console.debug("[dbg:idb] dbPut complete", path); resolve(); };
          tx.onerror = () => { console.error("[dbg:idb] dbPut error", path, tx.error); reject(tx.error); };
          tx.objectStore(STORE).put({ path, text });
        });
      }

      async function dbClear() {
        console.debug("[dbg:idb] dbClear called");
        const db = await openDB();
        return new Promise((resolve, reject) => {
          const tx = db.transaction(STORE, "readwrite");
          const req = tx.objectStore(STORE).clear();
          req.onsuccess = () => { console.debug("[dbg:idb] dbClear success"); resolve(); };
          req.onerror = () => { console.error("[dbg:idb] dbClear error", req.error); reject(req.error); };
        });
      }

      // -----------------------------
      // 1) VFS seed (editable)
      // -----------------------------
      const SEED = new Map([
        ["/src/main.tsx", `import React from "react";
import { createRoot } from "react-dom/client";
import { AgentMount } from "./agent-mount";
import Agent from "./agent";

declare global {
  interface Window {
    __RUNTIME__?: any;
    __AGENT_STATE__?: any;
  }
}

const el = document.getElementById("root")!;
const root = (window.__RUNTIME__.root ??= createRoot(el));

// Only mount on first render; React Refresh handles subsequent updates
if (!window.__RUNTIME__._mounted) {
  root.render(
    React.createElement(AgentMount, {
      agentPath: "/src/agent.tsx",
      AgentBody: Agent,
    })
  );
  window.__RUNTIME__._mounted = true;
}
`],

        ["/src/useAgentState.ts", `import { useSyncExternalStore, useCallback } from "react";

type AgentMemory = Record<string, any>;

export function useAgentState<T extends AgentMemory = AgentMemory>(): [T, (patch: Partial<T>) => void] {
  const memory = useSyncExternalStore(
    (cb) => window.__AGENT_STATE__.subscribe(cb),
    () => window.__AGENT_STATE__.get()
  ) as T;

  const setMemory = useCallback((patch: Partial<T>) => {
    window.__AGENT_STATE__.set(patch);
  }, []);

  return [memory, setMemory];
}

export function useAgentMeta() {
  return window.__AGENT_STATE__.meta;
}
`],

        ["/src/agent-mount.tsx", `import React, { Component, useCallback, useMemo } from "react";
import { useAgentState, useAgentMeta } from "./useAgentState";

// Error boundary for agent body isolation
class AgentErrorBoundary extends Component<
  { children: React.ReactNode; onError?: (error: Error) => void },
  { hasError: boolean; error: Error | null }
> {
  state = { hasError: false, error: null };

  static getDerivedStateFromError(error: Error) {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, info: React.ErrorInfo) {
    console.error("[agent-mount] Agent body crashed:", error, info);
    this.props.onError?.(error);
  }

  render() {
    if (this.state.hasError) {
      return (
        <div style={{ padding: 16, background: "#fff0f0", border: "1px solid #ff9a9a", borderRadius: 8 }}>
          <h3 style={{ margin: 0, color: "#c00" }}>Agent Error</h3>
          <pre style={{ margin: "8px 0 0", fontSize: 12, whiteSpace: "pre-wrap" }}>
            {this.state.error?.message}
          </pre>
          <button
            onClick={() => this.setState({ hasError: false, error: null })}
            style={{ marginTop: 8, padding: "4px 12px" }}
          >
            Retry
          </button>
        </div>
      );
    }
    return this.props.children;
  }
}

export interface AgentSelf {
  source: string;
  path: string;
  reason: (prompt: string) => Promise<string>;
  mutate: (newSource: string, reason?: string) => Promise<void>;
}

export interface AgentProps {
  state: Record<string, any>;
  act: (patch: Record<string, any>) => void;
  self: AgentSelf;
}

interface AgentMountProps {
  agentPath?: string;
  AgentBody: React.ComponentType<AgentProps>;
}

export function AgentMount({ agentPath = "/src/agent.tsx", AgentBody }: AgentMountProps) {
  const [state, act] = useAgentState();
  const meta = useAgentMeta();

  // The "self" object passed to agent body
  const self: AgentSelf = useMemo(() => ({
    get source() {
      return window.__RUNTIME__.files.get(agentPath) ?? "";
    },
    path: agentPath,
    reason: async (prompt: string) => {
      // Placeholder: logs and returns empty. LLM integration comes later.
      console.log("[agent] reason() called with:", prompt);
      meta.cycle++;
      // Future: Call Anthropic API here
      return "";
    },
    mutate: async (newSource: string, reason?: string) => {
      meta.mutations.push({
        timestamp: Date.now(),
        reason: reason ?? "self-mutation",
        path: agentPath,
      });
      await window.__RUNTIME__.applyPatch([{ path: agentPath, text: newSource, reason }]);
    },
  }), [agentPath, meta]);

  const handleError = useCallback((error: Error) => {
    act({ _lastError: error.message, _lastErrorTime: Date.now() });
  }, [act]);

  return (
    <AgentErrorBoundary onError={handleError}>
      <AgentBody state={state} act={act} self={self} />
    </AgentErrorBoundary>
  );
}
`],

        ["/src/agent.tsx", `import React, { useMemo, useState } from "react";
import styled from "styled-components";
import type { AgentProps } from "./agent-mount";

const Container = styled.div\`
  padding: 16px;
\`;

const Title = styled.h2\`
  margin-top: 0;
  background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
\`;

const Button = styled.button<{ $primary?: boolean }>\`
  padding: 8px 16px;
  border: 1px solid #ddd;
  border-radius: 6px;
  background: \${props => props.$primary ? 'linear-gradient(90deg, #667eea, #764ba2)' : '#fff'};
  color: \${props => props.$primary ? '#fff' : 'inherit'};
  cursor: pointer;
  transition: transform 0.1s;
  &:hover { transform: scale(1.02); }
  &:active { transform: scale(0.98); }
\`;

const ButtonRow = styled.div\`
  display: flex;
  gap: 10px;
  align-items: center;
  flex-wrap: wrap;
\`;

// This is the self-modifying agent body
export default function Agent({ state, act, self }: AgentProps) {
  // Test: local useState (resets on self-modify, but should work for normal clicks)
  const [localCount, setLocalCount] = useState(0);
  // External state (survives self-modify)
  const extCount = state.count ?? 0;
  const now = useMemo(() => new Date().toLocaleTimeString(), []);

  async function handleSelfModify() {
    const stamp = new Date().toISOString();
    const newSource = self.source + "\\n\\n// mutated at " + stamp + "\\n";
    await self.mutate(newSource, "self-mutate demo");
  }

  async function handleReason() {
    // Trigger reasoning (placeholder)
    const result = await self.reason("What should I do next?");
    console.log("[agent] reason result:", result);
  }

  return (
    <Container>
      <Title>Self-Modifying Agent</Title>
      <p style={{ opacity: 0.8, marginTop: 0 }}>
        This component can read and rewrite its own source code.
        <br />
        State survives self-modification via external store.
      </p>

      <ButtonRow>
        <Button $primary onClick={() => setLocalCount(c => c + 1)}>local: {localCount}</Button>
        <Button onClick={() => act({ count: extCount + 1 })}>external: {extCount}</Button>
        <Button onClick={handleSelfModify}>self-modify</Button>
        <Button onClick={handleReason}>reason()</Button>
      </ButtonRow>
      <p style={{ opacity: 0.7, fontFamily: "ui-monospace, monospace", fontSize: 12 }}>first render: {now}</p>

      <hr />

      <details>
        <summary>Agent capabilities</summary>
        <ul>
          <li><code>self.source</code> — read own source code</li>
          <li><code>self.mutate(src)</code> — rewrite self</li>
          <li><code>self.reason(prompt)</code> — trigger reasoning (LLM placeholder)</li>
          <li><code>state</code> / <code>act</code> — external memory</li>
        </ul>
      </details>
    </Container>
  );
}
`],

        ["/src/App.tsx", `import React, { useEffect, useMemo } from "react";
import styled from "styled-components";
import { useAgentState } from "./useAgentState";

const Container = styled.div\`
  padding: 16px;
\`;

const Title = styled.h2\`
  margin-top: 0;
  background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
\`;

const Button = styled.button<{ $primary?: boolean }>\`
  padding: 8px 16px;
  border: 1px solid #ddd;
  border-radius: 6px;
  background: \${props => props.$primary ? 'linear-gradient(90deg, #667eea, #764ba2)' : '#fff'};
  color: \${props => props.$primary ? '#fff' : 'inherit'};
  cursor: pointer;
  transition: transform 0.1s;
  &:hover { transform: scale(1.02); }
  &:active { transform: scale(0.98); }
\`;

const ButtonRow = styled.div\`
  display: flex;
  gap: 10px;
  align-items: center;
  flex-wrap: wrap;
\`;

export default function App() {
  // External state survives self-modification and hot reload
  const [memory, setMemory] = useAgentState<{ count: number }>();
  const count = memory.count ?? 0;

  // prove "self modification" works:
  // click the button to rewrite THIS file in the VFS.
  async function mutateMyOwnSource() {
    const rt = window.__RUNTIME__;
    if (!rt) return;

    const path = "/src/App.tsx";
    const src = rt.files.get(path);

    // Extremely dumb patch: append a comment with timestamp.
    const stamp = new Date().toISOString();
    const next = src + "\\n\\n// mutated at " + stamp + "\\n";

    await rt.applyPatch([{ path, text: next, reason: "self-mutate demo" }]);
  }

  const now = useMemo(() => new Date().toLocaleTimeString(), []);

  useEffect(() => {
    // Example of cleanup discipline (useful once we add real HMR dispose):
    return () => {};
  }, []);

  return (
    <Container>
      <Title>Clientside esbuild-wasm + TSX → Blob-ESM "hot reload"</Title>
      <p style={{ opacity: 0.8, marginTop: 0 }}>
        Build happens in-browser. Modules are stored in a virtual filesystem (IndexedDB).
        <br />
        <strong>State survives self-modification</strong> via external store.
      </p>

      <ButtonRow>
        <Button $primary onClick={() => setMemory({ count: count + 1 })}>count: {count}</Button>
        <Button onClick={mutateMyOwnSource}>self-modify /src/App.tsx</Button>
        <span style={{ opacity: 0.7, fontFamily: "ui-monospace, monospace" }}>first render: {now}</span>
      </ButtonRow>

      <hr />

      <details>
        <summary>What's happening?</summary>
        <ul>
          <li>We compile TSX with esbuild-wasm in a Web Worker.</li>
          <li>We create a Blob URL from the ESM output and import() it.</li>
          <li>Import triggers /src/main.tsx which re-renders the React root.</li>
          <li>No server, no filesystem watcher. Your runtime is the dev server.</li>
          <li><strong>State lives in window.__AGENT_STATE__</strong> — survives self-modification.</li>
          <li><strong>styled-components</strong> available for CSS-in-JS.</li>
        </ul>
      </details>
    </Container>
  );
}
`],
      ]);

      // -----------------------------
      // 2) Live VFS + UI
      // -----------------------------
      const statusEl = document.getElementById("status");
      const editorEl = document.getElementById("editor");
      const filesEl = document.getElementById("files");
      const runBtn = document.getElementById("runBtn");
      const resetBtn = document.getElementById("resetBtn");
      const modePill = document.getElementById("modePill");

      function setMode(mode, cls = "") {
        modePill.textContent = mode;
        modePill.className = "pill " + cls;
      }

      function logStatus(text) {
        statusEl.textContent = text;
      }

      const files = new Map(); // path -> text
      let activePath = "/src/agent.tsx";

      function renderFileButtons() {
        filesEl.innerHTML = "";
        [...files.keys()].sort().forEach((path) => {
          const btn = document.createElement("button");
          btn.textContent = path;
          btn.dataset.active = String(path === activePath);
          btn.onclick = () => {
            flushEditorToVFS();
            activePath = path;
            editorEl.value = files.get(activePath) ?? "";
            renderFileButtons();
          };
          filesEl.appendChild(btn);
        });
      }

      function flushEditorToVFS() {
        const current = files.get(activePath) ?? "";
        if (editorEl.value !== current) {
          console.debug("[dbg:vfs] flushEditorToVFS — dirty, saving", activePath, `(${editorEl.value.length} chars)`);
          files.set(activePath, editorEl.value);
          dbPut(activePath, editorEl.value).catch((e) => console.warn("[dbg:vfs] flushEditorToVFS dbPut failed:", e));
        } else {
          console.debug("[dbg:vfs] flushEditorToVFS — clean, no changes for", activePath);
        }
      }

      async function loadOrSeedFiles() {
        console.debug("[dbg:boot] loadOrSeedFiles called");
        const rows = await dbGetAll();
        if (rows.length === 0) {
          console.debug("[dbg:boot] no rows in DB — seeding from SEED map:", [...SEED.keys()]);
          for (const [p, t] of SEED.entries()) {
            files.set(p, t);
            await dbPut(p, t);
          }
          console.debug("[dbg:boot] seeding complete,", files.size, "files");
        } else {
          console.debug("[dbg:boot] loaded", rows.length, "files from DB:", rows.map(r => r.path));
          for (const r of rows) files.set(r.path, r.text);
        }
      }

      // -----------------------------
      // 3) React Refresh injection helper
      // -----------------------------
      function injectReactRefresh(code, filePath) {
        // Detect PascalCase function/const component names
        const componentRegex = /(?:export\s+(?:default\s+)?)?(?:function|const)\s+([A-Z][a-zA-Z0-9]*)/g;
        const components = [];
        let match;
        while ((match = componentRegex.exec(code)) !== null) {
          components.push(match[1]);
        }

        if (components.length === 0) {
          console.debug("[dbg:refresh] no components detected in", filePath);
          return code;
        }

        console.debug("[dbg:refresh] detected components in", filePath, ":", components);

        // Wrap module to save/restore globals, then register components
        const registrations = components
          .map(name => `  window.$RefreshReg$(${name}, "${name}");`)
          .join("\n");

        const wrapped = `
// React Refresh preamble
var prevRefreshReg = window.$RefreshReg$;
var prevRefreshSig = window.$RefreshSig$;
window.$RefreshReg$ = (type, id) => {
  window.__RUNTIME__.RefreshRuntime.register(type, "${filePath}" + " " + id);
};
window.$RefreshSig$ = window.__RUNTIME__.RefreshRuntime.createSignatureFunctionForTransform;

${code}

// React Refresh registration
${registrations}

// Restore globals
window.$RefreshReg$ = prevRefreshReg;
window.$RefreshSig$ = prevRefreshSig;
`;
        return wrapped;
      }

      // -----------------------------
      // 4) esbuild-wasm: VFS plugin
      // -----------------------------
      function vfsPlugin(filesMap) {
        console.debug("[dbg:vfs] creating vfsPlugin, filesMap keys:", [...filesMap.keys()]);
        return {
          name: "vfs",
          setup(build) {
            console.debug("[dbg:vfs] plugin setup called");

            build.onResolve({ filter: /.*/ }, (args) => {
              console.debug("[dbg:vfs:resolve]", { path: args.path, kind: args.kind, importer: args.importer, resolveDir: args.resolveDir });

              if (args.kind === "entry-point") {
                console.debug("[dbg:vfs:resolve] → entry-point, namespace=vfs", args.path);
                return { path: args.path, namespace: "vfs" };
              }

              // bare imports: react / react-dom etc
              if (!args.path.startsWith(".") && !args.path.startsWith("/")) {
                console.debug("[dbg:vfs:resolve] → external (bare import)", args.path);
                return { path: args.path, external: true };
              }

              const baseDir = args.resolveDir || "/";
              const resolved = new URL(args.path, "file://" + baseDir + "/").pathname;

              const candidates = [
                resolved,
                resolved + ".ts",
                resolved + ".tsx",
                resolved + ".js",
                resolved + ".jsx",
                resolved + "/index.ts",
                resolved + "/index.tsx",
                resolved + "/index.js",
                resolved + "/index.jsx",
              ];

              const hit = candidates.find((p) => filesMap.has(p));
              if (!hit) {
                console.error("[dbg:vfs:resolve] Module not found!", args.path, "from", args.importer, "tried:", candidates);
                throw new Error(`Module not found: ${args.path} (from ${args.importer || "?"})`);
              }
              console.debug("[dbg:vfs:resolve] → resolved", args.path, "→", hit);
              return { path: hit, namespace: "vfs" };
            });

            build.onLoad({ filter: /.*/, namespace: "vfs" }, (args) => {
              console.debug("[dbg:vfs:load]", args.path);
              let contents = filesMap.get(args.path);
              if (contents == null) {
                console.error("[dbg:vfs:load] Missing file!", args.path, "available:", [...filesMap.keys()]);
                throw new Error(`Missing file: ${args.path}`);
              }

              const loader =
                args.path.endsWith(".tsx") ? "tsx" :
                args.path.endsWith(".ts") ? "ts" :
                args.path.endsWith(".jsx") ? "jsx" : "js";

              // Inject React Refresh registration for TSX/JSX files
              if ((loader === "tsx" || loader === "jsx") && window.__RUNTIME__?.RefreshRuntime) {
                contents = injectReactRefresh(contents, args.path);
              }

              const resolveDir = args.path.slice(0, args.path.lastIndexOf("/")) || "/";
              console.debug("[dbg:vfs:load] →", args.path, `(${contents.length} chars, loader=${loader}, resolveDir=${resolveDir})`);
              return { contents, loader, resolveDir };
            });
          },
        };
      }

      // -----------------------------
      // 5) Build + Blob import + basic "hot reload"
      // -----------------------------
      let currentBlobUrl = null;
      let buildCounter = 0;

      async function initEsbuildOnce() {
        console.debug("[dbg:esbuild] initEsbuildOnce — starting wasm download…");
        const t0 = performance.now();
        setMode("init", "warn");
        await esbuild.initialize({
          wasmURL: "https://unpkg.com/esbuild-wasm@0.24.2/esbuild.wasm",
          worker: true,
        });
        const ms = Math.round(performance.now() - t0);
        console.debug(`[dbg:esbuild] initEsbuildOnce — ready in ${ms}ms`);
        setMode("ready");
      }

      async function buildBundle(entry = "/src/main.tsx") {
        console.debug("[dbg:build] buildBundle called, entry:", entry);
        console.debug("[dbg:build] VFS snapshot:", [...files.keys()]);
        const t0 = performance.now();

        const buildOpts = {
          entryPoints: [entry],
          bundle: true,
          format: "esm",
          platform: "browser",
          sourcemap: "inline",
          write: false,
          jsx: "automatic",
          plugins: [vfsPlugin(files)],
        };
        console.debug("[dbg:build] esbuild.build options:", { ...buildOpts, plugins: "(vfsPlugin)" });

        const result = await esbuild.build(buildOpts);

        console.debug("[dbg:build] esbuild.build result keys:", Object.keys(result));
        console.debug("[dbg:build] result.errors:", result.errors);
        console.debug("[dbg:build] result.warnings:", result.warnings);
        console.debug("[dbg:build] result.outputFiles count:", result.outputFiles?.length);
        console.debug("[dbg:build] result.outputFiles detail:", result.outputFiles?.map(f => ({
          path: f.path,
          bytes: f.contents?.byteLength,
          textLen: f.text?.length,
        })));

        const out = result.outputFiles?.[0];
        if (!out?.text) {
          console.error("[dbg:build] NO output! Full result:", JSON.stringify(result, null, 2));
          throw new Error(`esbuild produced no outputFiles (got: ${JSON.stringify(result, null, 2)})`);
        }
        const ms = Math.round(performance.now() - t0);
        console.debug(`[dbg:build] buildBundle OK in ${ms}ms, output ${out.text.length} chars`);
        return { code: out.text, ms };
      }

      function revokeOldBlob() {
        if (currentBlobUrl) {
          console.debug("[dbg:blob] revoking old blob URL:", currentBlobUrl);
          URL.revokeObjectURL(currentBlobUrl);
          currentBlobUrl = null;
        }
      }

      async function importBundle(code) {
        console.debug(`[dbg:import] importBundle called (${code.length} chars)`);
        console.debug("[dbg:import] code preview (first 200 chars):", code.slice(0, 200));
        revokeOldBlob();
        const blob = new Blob([code], { type: "text/javascript" });
        currentBlobUrl = URL.createObjectURL(blob);

        // Blob URLs are unique (UUID-based), so no cache-busting needed.
        // Appending ?v=... breaks blob URL resolution (browser can't find the blob).
        console.debug("[dbg:import] importing blob URL:", currentBlobUrl);
        try {
          const mod = await import(/* @vite-ignore */ currentBlobUrl);
          console.debug("[dbg:import] import() succeeded, module keys:", Object.keys(mod));
          return mod;
        } catch (err) {
          console.error("[dbg:import] import() FAILED:", err);
          throw err;
        }
      }

      // Minimal dispose protocol (for later)
      const disposers = [];
      function runDisposers() {
        console.debug("[dbg:dispose] runDisposers, count:", disposers.length);
        while (disposers.length) {
          const fn = disposers.pop();
          try { fn(); } catch (e) { console.warn("[dbg:dispose] disposer threw:", e); }
        }
        // Note: Do NOT remove styled-components style tags here.
        // React Refresh keeps components mounted, so styles remain valid.
        // Removing them would break styling since components don't remount.
      }

      async function buildAndRun(reason = "manual") {
        console.debug(`[dbg:run] ========== buildAndRun (reason: ${reason}) ==========`);
        flushEditorToVFS();
        setMode("building", "warn");
        logStatus(`Building (${reason})…`);

        try {
          console.debug("[dbg:run] calling buildBundle…");
          const { code, ms } = await buildBundle();
          buildCounter++;
          console.debug(`[dbg:run] buildBundle returned, build #${buildCounter}, ${ms}ms, ${code.length} chars`);

          // Dispose old listeners/intervals if you registered them (future expansion)
          runDisposers();

          setMode("importing", "warn");
          logStatus(`Build #${buildCounter} OK in ${ms}ms. Importing…`);

          console.debug("[dbg:run] calling importBundle…");
          await importBundle(code);

          // Trigger React Refresh after import
          if (window.__RUNTIME__?.RefreshRuntime) {
            setTimeout(() => {
              console.debug("[dbg:refresh] calling performReactRefresh");
              window.__RUNTIME__.RefreshRuntime.performReactRefresh();
            }, 30);
          }

          setMode("running");
          logStatus(`Build #${buildCounter} running. (${ms}ms)`);
          console.debug(`[dbg:run] ✓ build #${buildCounter} complete and running`);
        } catch (err) {
          console.error("[dbg:run] buildAndRun FAILED:", err);
          setMode("error", "err");
          logStatus(String(err?.stack || err));
        }
      }

      // -----------------------------
      // 6) External state store (survives self-modification)
      // -----------------------------
      window.__AGENT_STATE__ = {
        memory: {},
        meta: { cycle: 0, mutations: [] },
        _listeners: new Set(),
        get() {
          return this.memory;
        },
        set(patch) {
          // Create new object so useSyncExternalStore detects the change
          this.memory = { ...this.memory, ...patch };
          this._notify();
        },
        subscribe(fn) {
          this._listeners.add(fn);
          return () => this._listeners.delete(fn);
        },
        _notify() {
          this._listeners.forEach(fn => fn(this.memory));
        }
      };

      // -----------------------------
      // 7) Expose runtime globals for "self-modifying"
      // -----------------------------
      window.__RUNTIME__ = {
        files,
        disposers,
        async applyPatch(patches) {
          console.debug("[dbg:patch] applyPatch called, patches:", patches.map(p => ({ path: p.path, reason: p.reason, textLen: p.text?.length })));
          // patches: Array<{path, text, reason?}>
          for (const p of patches) {
            console.debug("[dbg:patch] setting", p.path, `(${p.text.length} chars, reason: ${p.reason || "none"})`);
            files.set(p.path, p.text);
            await dbPut(p.path, p.text);
            if (p.path === activePath) editorEl.value = p.text;
          }
          await buildAndRun("applyPatch");
        },
        async reset() {
          console.debug("[dbg:reset] reset called — clearing DB and reloading");
          await dbClear();
          location.reload();
        },
      };

      // -----------------------------
      // 8) Dev drawer toggle
      // -----------------------------
      const devToggle = document.getElementById("devToggle");
      const leftDrawer = document.getElementById("left");
      const drawerBackdrop = document.getElementById("drawerBackdrop");

      function openDrawer() {
        leftDrawer.classList.add("open");
        drawerBackdrop.classList.add("visible");
        devToggle.classList.add("active");
      }

      function closeDrawer() {
        leftDrawer.classList.remove("open");
        drawerBackdrop.classList.remove("visible");
        devToggle.classList.remove("active");
      }

      function toggleDrawer() {
        if (leftDrawer.classList.contains("open")) {
          closeDrawer();
        } else {
          openDrawer();
        }
      }

      devToggle.onclick = toggleDrawer;
      drawerBackdrop.onclick = closeDrawer;

      // Track unsaved changes for visual indicator
      let lastSavedContent = "";
      function updateUnsavedIndicator() {
        const current = editorEl.value;
        const saved = files.get(activePath) ?? "";
        if (current !== saved) {
          devToggle.classList.add("unsaved");
          devToggle.classList.remove("building");
        } else {
          devToggle.classList.remove("unsaved");
        }
      }

      editorEl.addEventListener("input", updateUnsavedIndicator);

      // Update setMode to show building indicator
      const originalSetMode = setMode;
      setMode = function(mode, cls = "") {
        originalSetMode(mode, cls);
        if (mode === "building" || mode === "importing") {
          devToggle.classList.add("building");
          devToggle.classList.remove("unsaved");
        } else {
          devToggle.classList.remove("building");
          updateUnsavedIndicator();
        }
      };

      // -----------------------------
      // 9) Wire UI + keyboard shortcuts
      // -----------------------------
      runBtn.onclick = () => buildAndRun("button");
      resetBtn.onclick = () => window.__RUNTIME__.reset();

      // Ctrl/Cmd+S triggers build
      // Ctrl/Cmd+\ or Ctrl/Cmd+E toggles dev drawer
      window.addEventListener("keydown", (e) => {
        const isSave = (e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "s";
        const isToggle = (e.ctrlKey || e.metaKey) && (e.key === "\\" || e.key.toLowerCase() === "e");

        if (isSave) {
          e.preventDefault();
          buildAndRun("Ctrl/Cmd+S");
        }
        if (isToggle) {
          e.preventDefault();
          toggleDrawer();
        }
        // Escape closes drawer
        if (e.key === "Escape" && leftDrawer.classList.contains("open")) {
          closeDrawer();
        }
      });

      // Debounced build after typing (optional; disabled by default)
      let debounceTimer = null;
      const AUTO_BUILD = false;
      editorEl.addEventListener("input", () => {
        if (!AUTO_BUILD) return;
        clearTimeout(debounceTimer);
        debounceTimer = setTimeout(() => buildAndRun("debounce"), 400);
      });

      // -----------------------------
      // 10) Boot
      // -----------------------------
      const refreshPill = document.getElementById("refreshPill");

      console.debug("[dbg:boot] ========== BOOT SEQUENCE START ==========");
      console.debug("[dbg:boot] step 1/5: loadOrSeedFiles");
      await loadOrSeedFiles();
      renderFileButtons();
      editorEl.value = files.get(activePath) ?? "";
      console.debug("[dbg:boot] step 2/5: VFS loaded, activePath:", activePath, "files:", [...files.keys()]);
      logStatus("Loaded VFS. Initial build pending…");

      console.debug("[dbg:boot] step 3/5: Initialize React Refresh");
      try {
        const RefreshRuntime = await import("react-refresh/runtime");
        RefreshRuntime.injectIntoGlobalHook(window);
        window.$RefreshReg$ = () => {};
        window.$RefreshSig$ = () => (type) => type;
        window.__RUNTIME__.RefreshRuntime = RefreshRuntime;
        refreshPill.textContent = "React Refresh active";
        refreshPill.classList.remove("warn");
        console.debug("[dbg:boot] React Refresh initialized successfully");
      } catch (err) {
        console.error("[dbg:boot] React Refresh failed to load:", err);
        refreshPill.textContent = "React Refresh failed";
        refreshPill.classList.add("err");
      }

      console.debug("[dbg:boot] step 4/5: initEsbuildOnce");
      await initEsbuildOnce();
      console.debug("[dbg:boot] step 5/5: buildAndRun(startup)");
      await buildAndRun("startup");
      console.debug("[dbg:boot] ========== BOOT SEQUENCE DONE ==========");
    </script>
  </body>
</html>
