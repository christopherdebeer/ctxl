<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>100% clientside TSX hot reload (esbuild-wasm + React)</title>

    <!-- Import map so our Blob-ESM bundle can resolve bare imports like "react" -->
    <script type="importmap">
      {
        "imports": {
          "react": "https://esm.sh/react@18.3.1",
          "react/jsx-runtime": "https://esm.sh/react@18.3.1/jsx-runtime",
          "react-dom/client": "https://esm.sh/react-dom@18.3.1/client"
        }
      }
    </script>

    <style>
      html, body { height: 100%; margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial; }
      #shell { display: grid; grid-template-columns: 1fr 1fr; height: 100%; }
      #left { border-right: 1px solid #ddd; display: grid; grid-template-rows: auto auto 1fr auto; }
      #toolbar { display: flex; gap: 8px; align-items: center; padding: 10px; border-bottom: 1px solid #eee; }
      #status { padding: 8px 10px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono"; font-size: 12px; border-bottom: 1px solid #eee; white-space: pre-wrap; }
      #editor { width: 100%; height: 100%; border: 0; resize: none; padding: 10px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono"; font-size: 12px; line-height: 1.4; outline: none; }
      #files { padding: 8px 10px; border-top: 1px solid #eee; display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
      #files button { font-family: ui-monospace, monospace; font-size: 12px; padding: 6px 8px; border: 1px solid #ddd; background: #fff; cursor: pointer; border-radius: 6px; }
      #files button[data-active="true"] { border-color: #000; }
      #right { display: grid; grid-template-rows: auto 1fr; }
      #previewTop { padding: 10px; border-bottom: 1px solid #eee; display: flex; gap: 8px; align-items: center; }
      #preview { height: 100%; }
      #root { height: 100%; }
      .pill { font-size: 12px; padding: 2px 8px; border: 1px solid #ddd; border-radius: 999px; }
      .warn { border-color: #f0c36d; background: #fff7e6; }
      .err  { border-color: #ff9a9a; background: #fff0f0; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/eruda"></script>

  </head>
  <body>
    <script>eruda.init();</script>
    <div id="shell">
      <div id="left">
        <div id="toolbar">
          <strong>VFS</strong>
          <span class="pill" id="modePill">idle</span>
          <button id="runBtn">Build & Run</button>
          <button id="resetBtn">Reset</button>
          <span style="opacity:.7;font-size:12px">Ctrl/Cmd+S builds. “Self-modify” via <code>window.__RUNTIME__.applyPatch(...)</code></span>
        </div>
        <div id="status"></div>
        <textarea id="editor" spellcheck="false"></textarea>
        <div id="files"></div>
      </div>

      <div id="right">
        <div id="previewTop">
          <strong>Preview</strong>
          <span class="pill warn">No React Refresh yet (state won’t always survive)</span>
          <span class="pill">Blob-ESM import</span>
        </div>
        <div id="preview">
          <div id="root"></div>
        </div>
      </div>
    </div>

    <!-- esbuild-wasm from CDN -->
    <script type="module">
      import * as esbuild from "https://unpkg.com/esbuild-wasm@0.24.2/esm/browser.min.js";

      // -----------------------------
      // Tiny IndexedDB helper
      // -----------------------------
      const DB_NAME = "vfs_hmr_demo";
      const STORE = "files";

      function openDB() {
        console.debug("[dbg:idb] openDB called");
        return new Promise((resolve, reject) => {
          const req = indexedDB.open(DB_NAME, 1);
          req.onupgradeneeded = () => {
            console.debug("[dbg:idb] onupgradeneeded — creating object store");
            const db = req.result;
            if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE, { keyPath: "path" });
          };
          req.onsuccess = () => { console.debug("[dbg:idb] openDB success"); resolve(req.result); };
          req.onerror = () => { console.error("[dbg:idb] openDB error", req.error); reject(req.error); };
        });
      }

      async function dbGetAll() {
        console.debug("[dbg:idb] dbGetAll called");
        const db = await openDB();
        return new Promise((resolve, reject) => {
          const tx = db.transaction(STORE, "readonly");
          const os = tx.objectStore(STORE);
          const req = os.getAll();
          req.onsuccess = () => { console.debug("[dbg:idb] dbGetAll →", req.result?.length, "rows"); resolve(req.result || []); };
          req.onerror = () => { console.error("[dbg:idb] dbGetAll error", req.error); reject(req.error); };
        });
      }

      async function dbPut(path, text) {
        console.debug("[dbg:idb] dbPut", path, `(${text.length} chars)`);
        const db = await openDB();
        return new Promise((resolve, reject) => {
          const tx = db.transaction(STORE, "readwrite");
          tx.oncomplete = () => { console.debug("[dbg:idb] dbPut complete", path); resolve(); };
          tx.onerror = () => { console.error("[dbg:idb] dbPut error", path, tx.error); reject(tx.error); };
          tx.objectStore(STORE).put({ path, text });
        });
      }

      async function dbClear() {
        console.debug("[dbg:idb] dbClear called");
        const db = await openDB();
        return new Promise((resolve, reject) => {
          const tx = db.transaction(STORE, "readwrite");
          const req = tx.objectStore(STORE).clear();
          req.onsuccess = () => { console.debug("[dbg:idb] dbClear success"); resolve(); };
          req.onerror = () => { console.error("[dbg:idb] dbClear error", req.error); reject(req.error); };
        });
      }

      // -----------------------------
      // 1) VFS seed (editable)
      // -----------------------------
      const SEED = new Map([
        ["/src/main.tsx", `import React from "react";
import { createRoot } from "react-dom/client";
import App from "./App";

declare global {
  interface Window {
    __RUNTIME__?: any;
  }
}

const el = document.getElementById("root")!;
const root = (window.__RUNTIME__.root ??= createRoot(el));

// Minimal "hot rerender": we re-render the App after each import.
// (React Refresh comes later for state-preserving swaps.)
root.render(React.createElement(App));
`],

        ["/src/App.tsx", `import React, { useEffect, useMemo, useState } from "react";

export default function App() {
  const [count, setCount] = useState(0);

  // prove "self modification" works:
  // click the button to rewrite THIS file in the VFS.
  async function mutateMyOwnSource() {
    const rt = window.__RUNTIME__;
    if (!rt) return;

    const path = "/src/App.tsx";
    const src = rt.files.get(path);

    // Extremely dumb patch: append a comment with timestamp.
    const stamp = new Date().toISOString();
    const next = src + "\\n\\n// mutated at " + stamp + "\\n";

    await rt.applyPatch([{ path, text: next, reason: "self-mutate demo" }]);
  }

  const now = useMemo(() => new Date().toLocaleTimeString(), []);

  useEffect(() => {
    // Example of cleanup discipline (useful once we add real HMR dispose):
    return () => {};
  }, []);

  return (
    <div style={{ padding: 16 }}>
      <h2 style={{ marginTop: 0 }}>Clientside esbuild-wasm + TSX → Blob-ESM “hot reload”</h2>
      <p style={{ opacity: 0.8, marginTop: 0 }}>
        Build happens in-browser. Modules are stored in a virtual filesystem (IndexedDB).
      </p>

      <div style={{ display: "flex", gap: 10, alignItems: "center", flexWrap: "wrap" }}>
        <button onClick={() => setCount((c) => c + 1)}>count: {count}</button>
        <button onClick={mutateMyOwnSource}>self-modify /src/App.tsx</button>
        <span style={{ opacity: 0.7, fontFamily: "ui-monospace, monospace" }}>first render: {now}</span>
      </div>

      <hr />

      <details>
        <summary>What’s happening?</summary>
        <ul>
          <li>We compile TSX with esbuild-wasm in a Web Worker.</li>
          <li>We create a Blob URL from the ESM output and import() it.</li>
          <li>Import triggers /src/main.tsx which re-renders the React root.</li>
          <li>No server, no filesystem watcher. Your runtime is the dev server.</li>
        </ul>
      </details>
    </div>
  );
}
`],
      ]);

      // -----------------------------
      // 2) Live VFS + UI
      // -----------------------------
      const statusEl = document.getElementById("status");
      const editorEl = document.getElementById("editor");
      const filesEl = document.getElementById("files");
      const runBtn = document.getElementById("runBtn");
      const resetBtn = document.getElementById("resetBtn");
      const modePill = document.getElementById("modePill");

      function setMode(mode, cls = "") {
        modePill.textContent = mode;
        modePill.className = "pill " + cls;
      }

      function logStatus(text) {
        statusEl.textContent = text;
      }

      const files = new Map(); // path -> text
      let activePath = "/src/App.tsx";

      function renderFileButtons() {
        filesEl.innerHTML = "";
        [...files.keys()].sort().forEach((path) => {
          const btn = document.createElement("button");
          btn.textContent = path;
          btn.dataset.active = String(path === activePath);
          btn.onclick = () => {
            flushEditorToVFS();
            activePath = path;
            editorEl.value = files.get(activePath) ?? "";
            renderFileButtons();
          };
          filesEl.appendChild(btn);
        });
      }

      function flushEditorToVFS() {
        const current = files.get(activePath) ?? "";
        if (editorEl.value !== current) {
          console.debug("[dbg:vfs] flushEditorToVFS — dirty, saving", activePath, `(${editorEl.value.length} chars)`);
          files.set(activePath, editorEl.value);
          dbPut(activePath, editorEl.value).catch((e) => console.warn("[dbg:vfs] flushEditorToVFS dbPut failed:", e));
        } else {
          console.debug("[dbg:vfs] flushEditorToVFS — clean, no changes for", activePath);
        }
      }

      async function loadOrSeedFiles() {
        console.debug("[dbg:boot] loadOrSeedFiles called");
        const rows = await dbGetAll();
        if (rows.length === 0) {
          console.debug("[dbg:boot] no rows in DB — seeding from SEED map:", [...SEED.keys()]);
          for (const [p, t] of SEED.entries()) {
            files.set(p, t);
            await dbPut(p, t);
          }
          console.debug("[dbg:boot] seeding complete,", files.size, "files");
        } else {
          console.debug("[dbg:boot] loaded", rows.length, "files from DB:", rows.map(r => r.path));
          for (const r of rows) files.set(r.path, r.text);
        }
      }

      // -----------------------------
      // 3) esbuild-wasm: VFS plugin
      // -----------------------------
      function vfsPlugin(filesMap) {
        console.debug("[dbg:vfs] creating vfsPlugin, filesMap keys:", [...filesMap.keys()]);
        return {
          name: "vfs",
          setup(build) {
            console.debug("[dbg:vfs] plugin setup called");

            build.onResolve({ filter: /.*/ }, (args) => {
              console.debug("[dbg:vfs:resolve]", { path: args.path, kind: args.kind, importer: args.importer, resolveDir: args.resolveDir });

              if (args.kind === "entry-point") {
                console.debug("[dbg:vfs:resolve] → entry-point, namespace=vfs", args.path);
                return { path: args.path, namespace: "vfs" };
              }

              // bare imports: react / react-dom etc
              if (!args.path.startsWith(".") && !args.path.startsWith("/")) {
                console.debug("[dbg:vfs:resolve] → external (bare import)", args.path);
                return { path: args.path, external: true };
              }

              const baseDir = args.resolveDir || "/";
              const resolved = new URL(args.path, "file://" + baseDir + "/").pathname;

              const candidates = [
                resolved,
                resolved + ".ts",
                resolved + ".tsx",
                resolved + ".js",
                resolved + ".jsx",
                resolved + "/index.ts",
                resolved + "/index.tsx",
                resolved + "/index.js",
                resolved + "/index.jsx",
              ];

              const hit = candidates.find((p) => filesMap.has(p));
              if (!hit) {
                console.error("[dbg:vfs:resolve] Module not found!", args.path, "from", args.importer, "tried:", candidates);
                throw new Error(`Module not found: ${args.path} (from ${args.importer || "?"})`);
              }
              console.debug("[dbg:vfs:resolve] → resolved", args.path, "→", hit);
              return { path: hit, namespace: "vfs" };
            });

            build.onLoad({ filter: /.*/, namespace: "vfs" }, (args) => {
              console.debug("[dbg:vfs:load]", args.path);
              const contents = filesMap.get(args.path);
              if (contents == null) {
                console.error("[dbg:vfs:load] Missing file!", args.path, "available:", [...filesMap.keys()]);
                throw new Error(`Missing file: ${args.path}`);
              }

              const loader =
                args.path.endsWith(".tsx") ? "tsx" :
                args.path.endsWith(".ts") ? "ts" :
                args.path.endsWith(".jsx") ? "jsx" : "js";

              const resolveDir = args.path.slice(0, args.path.lastIndexOf("/")) || "/";
              console.debug("[dbg:vfs:load] →", args.path, `(${contents.length} chars, loader=${loader}, resolveDir=${resolveDir})`);
              return { contents, loader, resolveDir };
            });
          },
        };
      }

      // -----------------------------
      // 4) Build + Blob import + basic "hot reload"
      // -----------------------------
      let currentBlobUrl = null;
      let buildCounter = 0;

      async function initEsbuildOnce() {
        console.debug("[dbg:esbuild] initEsbuildOnce — starting wasm download…");
        const t0 = performance.now();
        setMode("init", "warn");
        await esbuild.initialize({
          wasmURL: "https://unpkg.com/esbuild-wasm@0.24.2/esbuild.wasm",
          worker: true,
        });
        const ms = Math.round(performance.now() - t0);
        console.debug(`[dbg:esbuild] initEsbuildOnce — ready in ${ms}ms`);
        setMode("ready");
      }

      async function buildBundle(entry = "/src/main.tsx") {
        console.debug("[dbg:build] buildBundle called, entry:", entry);
        console.debug("[dbg:build] VFS snapshot:", [...files.keys()]);
        const t0 = performance.now();

        const buildOpts = {
          entryPoints: [entry],
          bundle: true,
          format: "esm",
          platform: "browser",
          sourcemap: "inline",
          write: false,
          jsx: "automatic",
          plugins: [vfsPlugin(files)],
        };
        console.debug("[dbg:build] esbuild.build options:", { ...buildOpts, plugins: "(vfsPlugin)" });

        const result = await esbuild.build(buildOpts);

        console.debug("[dbg:build] esbuild.build result keys:", Object.keys(result));
        console.debug("[dbg:build] result.errors:", result.errors);
        console.debug("[dbg:build] result.warnings:", result.warnings);
        console.debug("[dbg:build] result.outputFiles count:", result.outputFiles?.length);
        console.debug("[dbg:build] result.outputFiles detail:", result.outputFiles?.map(f => ({
          path: f.path,
          bytes: f.contents?.byteLength,
          textLen: f.text?.length,
        })));

        const out = result.outputFiles?.[0];
        if (!out?.text) {
          console.error("[dbg:build] NO output! Full result:", JSON.stringify(result, null, 2));
          throw new Error(`esbuild produced no outputFiles (got: ${JSON.stringify(result, null, 2)})`);
        }
        const ms = Math.round(performance.now() - t0);
        console.debug(`[dbg:build] buildBundle OK in ${ms}ms, output ${out.text.length} chars`);
        return { code: out.text, ms };
      }

      function revokeOldBlob() {
        if (currentBlobUrl) {
          console.debug("[dbg:blob] revoking old blob URL:", currentBlobUrl);
          URL.revokeObjectURL(currentBlobUrl);
          currentBlobUrl = null;
        }
      }

      async function importBundle(code) {
        console.debug(`[dbg:import] importBundle called (${code.length} chars)`);
        console.debug("[dbg:import] code preview (first 200 chars):", code.slice(0, 200));
        revokeOldBlob();
        const blob = new Blob([code], { type: "text/javascript" });
        currentBlobUrl = URL.createObjectURL(blob);

        // Cache-bust to avoid weird module caching
        const url = `${currentBlobUrl}?v=${Date.now()}`;
        console.debug("[dbg:import] importing blob URL:", url);
        try {
          const mod = await import(/* @vite-ignore */ url);
          console.debug("[dbg:import] import() succeeded, module keys:", Object.keys(mod));
          return mod;
        } catch (err) {
          console.error("[dbg:import] import() FAILED:", err);
          throw err;
        }
      }

      // Minimal dispose protocol (for later)
      const disposers = [];
      function runDisposers() {
        console.debug("[dbg:dispose] runDisposers, count:", disposers.length);
        while (disposers.length) {
          const fn = disposers.pop();
          try { fn(); } catch (e) { console.warn("[dbg:dispose] disposer threw:", e); }
        }
      }

      async function buildAndRun(reason = "manual") {
        console.debug(`[dbg:run] ========== buildAndRun (reason: ${reason}) ==========`);
        flushEditorToVFS();
        setMode("building", "warn");
        logStatus(`Building (${reason})…`);

        try {
          console.debug("[dbg:run] calling buildBundle…");
          const { code, ms } = await buildBundle();
          buildCounter++;
          console.debug(`[dbg:run] buildBundle returned, build #${buildCounter}, ${ms}ms, ${code.length} chars`);

          // Dispose old listeners/intervals if you registered them (future expansion)
          runDisposers();

          setMode("importing", "warn");
          logStatus(`Build #${buildCounter} OK in ${ms}ms. Importing…`);

          console.debug("[dbg:run] calling importBundle…");
          await importBundle(code);

          setMode("running");
          logStatus(`Build #${buildCounter} running. (${ms}ms)`);
          console.debug(`[dbg:run] ✓ build #${buildCounter} complete and running`);
        } catch (err) {
          console.error("[dbg:run] buildAndRun FAILED:", err);
          setMode("error", "err");
          logStatus(String(err?.stack || err));
        }
      }

      // -----------------------------
      // 5) Expose runtime globals for “self-modifying”
      // -----------------------------
      window.__RUNTIME__ = {
        files,
        disposers,
        async applyPatch(patches) {
          console.debug("[dbg:patch] applyPatch called, patches:", patches.map(p => ({ path: p.path, reason: p.reason, textLen: p.text?.length })));
          // patches: Array<{path, text, reason?}>
          for (const p of patches) {
            console.debug("[dbg:patch] setting", p.path, `(${p.text.length} chars, reason: ${p.reason || "none"})`);
            files.set(p.path, p.text);
            await dbPut(p.path, p.text);
            if (p.path === activePath) editorEl.value = p.text;
          }
          await buildAndRun("applyPatch");
        },
        async reset() {
          console.debug("[dbg:reset] reset called — clearing DB and reloading");
          await dbClear();
          location.reload();
        },
      };

      // -----------------------------
      // 6) Wire UI + keyboard shortcuts
      // -----------------------------
      runBtn.onclick = () => buildAndRun("button");
      resetBtn.onclick = () => window.__RUNTIME__.reset();

      // Ctrl/Cmd+S triggers build
      window.addEventListener("keydown", (e) => {
        const isSave = (e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "s";
        if (isSave) {
          e.preventDefault();
          buildAndRun("Ctrl/Cmd+S");
        }
      });

      // Debounced build after typing (optional; disabled by default)
      let debounceTimer = null;
      const AUTO_BUILD = false;
      editorEl.addEventListener("input", () => {
        if (!AUTO_BUILD) return;
        clearTimeout(debounceTimer);
        debounceTimer = setTimeout(() => buildAndRun("debounce"), 400);
      });

      // -----------------------------
      // 7) Boot
      // -----------------------------
      console.debug("[dbg:boot] ========== BOOT SEQUENCE START ==========");
      console.debug("[dbg:boot] step 1/4: loadOrSeedFiles");
      await loadOrSeedFiles();
      renderFileButtons();
      editorEl.value = files.get(activePath) ?? "";
      console.debug("[dbg:boot] step 2/4: VFS loaded, activePath:", activePath, "files:", [...files.keys()]);
      logStatus("Loaded VFS. Initial build pending…");
      console.debug("[dbg:boot] step 3/4: initEsbuildOnce");
      await initEsbuildOnce();
      console.debug("[dbg:boot] step 4/4: buildAndRun(startup)");
      await buildAndRun("startup");
      console.debug("[dbg:boot] ========== BOOT SEQUENCE DONE ==========");
    </script>
  </body>
</html>
