<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>100% clientside TSX hot reload (esbuild-wasm + React)</title>

    <!-- Import map so our Blob-ESM bundle can resolve bare imports like "react" -->
    <script type="importmap">
      {
        "imports": {
          "react": "https://esm.sh/react@18.3.1",
          "react/jsx-runtime": "https://esm.sh/react@18.3.1/jsx-runtime",
          "react-dom/client": "https://esm.sh/react-dom@18.3.1/client",
          "react-refresh/runtime": "https://esm.sh/react-refresh@0.14.2/runtime",
          "styled-components": "https://esm.sh/styled-components@6?deps=react@18.3.1,react-dom@18.3.1&external=react,react-dom"
        }
      }
    </script>

    <style>
      html, body { height: 100%; margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial; }

      /* Agent-first layout: preview takes full viewport */
      #shell { display: grid; grid-template-columns: 1fr; grid-template-rows: 1fr; height: 100%; }

      /* Dev drawer - hidden by default, slides in from left */
      #left {
        position: fixed;
        left: 0; top: 0; bottom: 0;
        width: 50vw;
        transform: translateX(-100%);
        transition: transform 0.2s ease;
        z-index: 100;
        background: #fff;
        box-shadow: 2px 0 10px rgba(0,0,0,0.1);
        display: grid;
        grid-template-rows: auto auto 1fr auto;
      }
      #left.open { transform: translateX(0); }

      /* Backdrop overlay when drawer is open */
      #drawerBackdrop {
        display: none;
        position: fixed;
        inset: 0;
        background: rgba(0,0,0,0.3);
        z-index: 99;
      }
      #drawerBackdrop.visible { display: block; }

      #toolbar { display: flex; gap: 8px; align-items: center; padding: 10px; border-bottom: 1px solid #eee; }
      #status { padding: 8px 10px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono"; font-size: 12px; border-bottom: 1px solid #eee; white-space: pre-wrap; }
      #editor { width: 100%; height: 100%; border: 0; resize: none; padding: 10px; font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono"; font-size: 12px; line-height: 1.4; outline: none; box-sizing: border-box; }
      #files { padding: 8px 10px; border-top: 1px solid #eee; display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
      #files button { font-family: ui-monospace, monospace; font-size: 12px; padding: 6px 8px; border: 1px solid #ddd; background: #fff; cursor: pointer; border-radius: 6px; }
      #files button[data-active="true"] { border-color: #000; }

      /* Preview takes full space */
      #right { display: grid; grid-template-rows: auto 1fr; height: 100%; }
      #previewTop { padding: 10px; border-bottom: 1px solid #eee; display: flex; gap: 8px; align-items: center; }
      #preview { height: 100%; position: relative; }
      #root { height: 100%; }

      /* View mode tabs */
      .viewTabs { display: flex; gap: 0; margin-right: auto; }
      .viewTab {
        padding: 6px 14px;
        border: 1px solid #ddd;
        background: #fff;
        cursor: pointer;
        font-size: 13px;
        font-weight: 500;
        transition: background 0.15s, border-color 0.15s;
      }
      .viewTab:first-child { border-radius: 6px 0 0 6px; }
      .viewTab:last-child { border-radius: 0 6px 6px 0; }
      .viewTab:not(:first-child) { border-left: none; }
      .viewTab:hover { background: #f5f5f5; }
      .viewTab.active { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: #fff; border-color: #667eea; }
      .viewTab.active + .viewTab { border-left-color: #667eea; }

      /* About view */
      #about {
        display: none;
        height: 100%;
        overflow-y: auto;
        padding: 32px;
        box-sizing: border-box;
      }
      #about.active { display: block; }
      #root.hidden { display: none; }

      /* Markdown styling */
      #about .markdown-body {
        max-width: 800px;
        margin: 0 auto;
        line-height: 1.7;
      }
      #about h1 { font-size: 2rem; font-weight: 300; margin-bottom: 0.5rem; }
      #about h2 { font-size: 1.4rem; margin-top: 2.5rem; padding-bottom: 0.3rem; border-bottom: 1px solid #eee; }
      #about h3 { font-size: 1.1rem; margin-top: 1.5rem; }
      #about p { margin: 1rem 0; }
      #about code { background: #f5f5f5; padding: 2px 6px; border-radius: 4px; font-size: 0.9em; }
      #about pre { background: #f8f8f8; padding: 16px; border-radius: 8px; overflow-x: auto; }
      #about pre code { background: none; padding: 0; }
      #about table { border-collapse: collapse; width: 100%; margin: 1rem 0; }
      #about th, #about td { border: 1px solid #ddd; padding: 8px 12px; text-align: left; }
      #about th { background: #f8f8f8; }
      #about blockquote { border-left: 3px solid #667eea; margin: 1rem 0; padding-left: 1rem; color: #666; }
      #about hr { border: none; border-top: 1px solid #eee; margin: 2rem 0; }
      #about ul, #about ol { padding-left: 1.5rem; }
      #about li { margin: 0.3rem 0; }

      .pill { font-size: 12px; padding: 2px 8px; border: 1px solid #ddd; border-radius: 999px; }
      .warn { border-color: #f0c36d; background: #fff7e6; }
      .err  { border-color: #ff9a9a; background: #fff0f0; }

      /* Dev toggle button */
      #devToggle {
        padding: 6px 12px;
        border: 1px solid #ddd;
        border-radius: 6px;
        background: #fff;
        cursor: pointer;
        font-size: 13px;
        font-weight: 500;
        display: flex;
        align-items: center;
        gap: 6px;
        transition: background 0.15s, border-color 0.15s;
      }
      #devToggle:hover { background: #f5f5f5; border-color: #ccc; }
      #devToggle.active { background: #f0f0f0; border-color: #999; }

      /* Unsaved indicator dot */
      #devToggle .indicator {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        display: none;
      }
      #devToggle.unsaved .indicator {
        display: block;
        background: #f0c36d;
      }
      #devToggle.building .indicator {
        display: block;
        background: #667eea;
        animation: pulse 1s infinite;
      }
      @keyframes pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.4; }
      }

      /* Mobile viewport */
      @media (max-width: 768px) {
        /* Drawer covers full width on mobile */
        #left {
          width: 100vw;
        }
        #toolbar { flex-wrap: wrap; }
        #toolbar button { min-height: 44px; min-width: 44px; padding: 10px 16px; }
        #files { overflow-x: auto; flex-wrap: nowrap; -webkit-overflow-scrolling: touch; }
        #files button { min-height: 44px; flex-shrink: 0; }
        #editor { min-height: 200px; }
        #previewTop { flex-wrap: wrap; }
        #devToggle { min-height: 44px; min-width: 44px; }
        .viewTab { min-height: 44px; display: flex; align-items: center; }
        #about { padding: 16px; }
      }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/eruda"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>

  </head>
  <body>
    <script>eruda.init();</script>
    <div id="shell">
      <!-- Backdrop for drawer -->
      <div id="drawerBackdrop"></div>

      <!-- Dev drawer (hidden by default) -->
      <div id="left">
        <div id="toolbar">
          <strong>VFS</strong>
          <span class="pill" id="modePill">idle</span>
          <button id="runBtn">Build & Run</button>
          <button id="resetBtn">Reset</button>
          <button id="settingsBtn">API</button>
          <span style="opacity:.7;font-size:12px">Ctrl/Cmd+S builds</span>
        </div>
        <div id="settings" style="display:none; padding:10px; border-bottom:1px solid #eee; background:#f9f9f9;">
          <div style="margin-bottom:8px;">
            <label style="font-size:12px;font-weight:500;">API Mode:</label>
            <select id="apiModeSelect" style="margin-left:8px; padding:4px;">
              <option value="none">None (disabled)</option>
              <option value="anthropic">Anthropic Direct</option>
              <option value="proxy">Proxy Server</option>
            </select>
          </div>
          <div id="apiKeyRow" style="display:none; margin-bottom:8px;">
            <label style="font-size:12px;font-weight:500;">API Key:</label>
            <input type="password" id="apiKeyInput" style="margin-left:8px; padding:4px; width:200px;" placeholder="sk-ant-...">
          </div>
          <div id="proxyUrlRow" style="display:none; margin-bottom:8px;">
            <label style="font-size:12px;font-weight:500;">Proxy URL:</label>
            <input type="text" id="proxyUrlInput" style="margin-left:8px; padding:4px; width:250px;" placeholder="http://localhost:3001/api/chat">
          </div>
          <button id="saveSettingsBtn" style="padding:4px 12px;">Save</button>
          <span id="settingsStatus" style="margin-left:8px; font-size:12px; color:#666;"></span>
        </div>
        <div id="status"></div>
        <textarea id="editor" spellcheck="false"></textarea>
        <div id="files"></div>
      </div>

      <!-- Agent preview (full viewport) -->
      <div id="right">
        <div id="previewTop">
          <button id="devToggle">Dev<span class="indicator"></span></button>
          <div class="viewTabs">
            <button class="viewTab active" data-view="component">Component</button>
            <button class="viewTab" data-view="about">About</button>
          </div>
          <span class="pill" id="refreshPill">React Refresh loading…</span>
          <span class="pill" id="blobPill">Blob-ESM</span>
        </div>
        <div id="preview">
          <div id="root"></div>
          <div id="about"><div class="markdown-body"></div></div>
        </div>
      </div>
    </div>

    <!-- esbuild-wasm from CDN -->
    <script type="module">
      import * as esbuild from "https://unpkg.com/esbuild-wasm@0.24.2/esm/browser.min.js";

      // -----------------------------
      // Tiny IndexedDB helper
      // -----------------------------
      const DB_NAME = "vfs_hmr_demo";
      const STORE = "files";

      function openDB() {
        console.debug("[dbg:idb] openDB called");
        return new Promise((resolve, reject) => {
          const req = indexedDB.open(DB_NAME, 1);
          req.onupgradeneeded = () => {
            console.debug("[dbg:idb] onupgradeneeded — creating object store");
            const db = req.result;
            if (!db.objectStoreNames.contains(STORE)) db.createObjectStore(STORE, { keyPath: "path" });
          };
          req.onsuccess = () => { console.debug("[dbg:idb] openDB success"); resolve(req.result); };
          req.onerror = () => { console.error("[dbg:idb] openDB error", req.error); reject(req.error); };
        });
      }

      async function dbGetAll() {
        console.debug("[dbg:idb] dbGetAll called");
        const db = await openDB();
        return new Promise((resolve, reject) => {
          const tx = db.transaction(STORE, "readonly");
          const os = tx.objectStore(STORE);
          const req = os.getAll();
          req.onsuccess = () => { console.debug("[dbg:idb] dbGetAll →", req.result?.length, "rows"); resolve(req.result || []); };
          req.onerror = () => { console.error("[dbg:idb] dbGetAll error", req.error); reject(req.error); };
        });
      }

      async function dbPut(path, text) {
        console.debug("[dbg:idb] dbPut", path, `(${text.length} chars)`);
        const db = await openDB();
        return new Promise((resolve, reject) => {
          const tx = db.transaction(STORE, "readwrite");
          tx.oncomplete = () => { console.debug("[dbg:idb] dbPut complete", path); resolve(); };
          tx.onerror = () => { console.error("[dbg:idb] dbPut error", path, tx.error); reject(tx.error); };
          tx.objectStore(STORE).put({ path, text });
        });
      }

      async function dbClear() {
        console.debug("[dbg:idb] dbClear called");
        const db = await openDB();
        return new Promise((resolve, reject) => {
          const tx = db.transaction(STORE, "readwrite");
          const req = tx.objectStore(STORE).clear();
          req.onsuccess = () => { console.debug("[dbg:idb] dbClear success"); resolve(); };
          req.onerror = () => { console.error("[dbg:idb] dbClear error", req.error); reject(req.error); };
        });
      }

      // -----------------------------
      // 1) VFS seed (editable)
      // -----------------------------
      const SEED = new Map([
        ["/src/main.tsx", `import React from "react";
import { createRoot } from "react-dom/client";
import { AgentMount } from "./agent-mount";
import Agent from "./agent";

declare global {
  interface Window {
    __RUNTIME__?: any;
    __AGENT_STATE__?: any;
  }
}

// Store the Agent component in runtime so AgentMount always gets the latest version
window.__RUNTIME__.AgentModule = { default: Agent };

const el = document.getElementById("root")!;
const root = (window.__RUNTIME__.root ??= createRoot(el));

// Only mount on first render; React Refresh handles subsequent updates
if (!window.__RUNTIME__._mounted) {
  root.render(
    React.createElement(AgentMount, {
      agentPath: "/src/agent.tsx",
    })
  );
  window.__RUNTIME__._mounted = true;
}
`],

        ["/src/useAgentState.ts", `import { useSyncExternalStore, useCallback } from "react";

type AgentMemory = Record<string, any>;

export function useAgentState<T extends AgentMemory = AgentMemory>(): [T, (patch: Partial<T>) => void] {
  const memory = useSyncExternalStore(
    (cb) => window.__AGENT_STATE__.subscribe(cb),
    () => window.__AGENT_STATE__.get()
  ) as T;

  const setMemory = useCallback((patch: Partial<T>) => {
    window.__AGENT_STATE__.set(patch);
  }, []);

  return [memory, setMemory];
}

export function useAgentMeta() {
  return window.__AGENT_STATE__.meta;
}
`],

        ["/src/agent-mount.tsx", `import React, { Component, useCallback, useMemo } from "react";
import { useAgentState, useAgentMeta } from "./useAgentState";

// Error boundary for agent body isolation
class AgentErrorBoundary extends Component<
  { children: React.ReactNode; onError?: (error: Error) => void },
  { hasError: boolean; error: Error | null }
> {
  state = { hasError: false, error: null };

  static getDerivedStateFromError(error: Error) {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, info: React.ErrorInfo) {
    console.error("[agent-mount] Agent body crashed:", error, info);
    this.props.onError?.(error);
  }

  render() {
    if (this.state.hasError) {
      return (
        <div style={{ padding: 16, background: "#fff0f0", border: "1px solid #ff9a9a", borderRadius: 8 }}>
          <h3 style={{ margin: 0, color: "#c00" }}>Agent Error</h3>
          <pre style={{ margin: "8px 0 0", fontSize: 12, whiteSpace: "pre-wrap" }}>
            {this.state.error?.message}
          </pre>
          <button
            onClick={() => this.setState({ hasError: false, error: null })}
            style={{ marginTop: 8, padding: "4px 12px" }}
          >
            Retry
          </button>
        </div>
      );
    }
    return this.props.children;
  }
}

export interface AgentSelf {
  source: string;
  path: string;
  isReasoning: boolean;
  reason: (prompt: string) => Promise<string>;
  mutate: (newSource: string, reason?: string) => Promise<void>;
}

export interface AgentProps {
  state: Record<string, any>;
  act: (patch: Record<string, any>) => void;
  self: AgentSelf;
}

interface AgentMountProps {
  agentPath?: string;
}

export function AgentMount({ agentPath = "/src/agent.tsx" }: AgentMountProps) {
  // Get the latest Agent component from the runtime module (updated on each build)
  // Use 'let' to avoid React Refresh detecting this as a component definition
  let AgentBody = window.__RUNTIME__.AgentModule?.default;
  const [state, act] = useAgentState();
  const meta = useAgentMeta();
  const [isReasoning, setIsReasoning] = React.useState(false);

  // The "self" object passed to agent body
  const self: AgentSelf = useMemo(() => ({
    get source() {
      return window.__RUNTIME__.files.get(agentPath) ?? "";
    },
    path: agentPath,
    get isReasoning() {
      return isReasoning;
    },
    reason: async (prompt: string) => {
      console.log("[agent] reason() called with:", prompt);
      setIsReasoning(true);
      meta.cycle++;

      try {
        // Call the LLM via __RUNTIME__
        const { error, content } = await window.__RUNTIME__.reason(prompt, agentPath);

        if (error) {
          console.error("[agent] reasoning failed:", error);
          act({ _reasoningError: error });
          return "";
        }

        // If response looks like source code, apply it as a mutation
        if (content && content.trim().startsWith("import ")) {
          console.log("[agent] LLM returned source code, applying mutation");
          meta.mutations.push({
            timestamp: Date.now(),
            reason: prompt,
            path: agentPath,
          });
          await window.__RUNTIME__.applyPatch([{ path: agentPath, text: content, reason: prompt }]);
        }

        return content || "";
      } finally {
        setIsReasoning(false);
      }
    },
    mutate: async (newSource: string, reason?: string) => {
      meta.mutations.push({
        timestamp: Date.now(),
        reason: reason ?? "self-mutation",
        path: agentPath,
      });
      await window.__RUNTIME__.applyPatch([{ path: agentPath, text: newSource, reason }]);
    },
  }), [agentPath, meta, isReasoning]);

  const handleError = useCallback((error: Error) => {
    act({ _lastError: error.message, _lastErrorTime: Date.now() });
  }, [act]);

  // Show loading state if AgentBody is not yet available
  if (!AgentBody) {
    return <div style={{ padding: 32, textAlign: "center", color: "#666" }}>Loading agent...</div>;
  }

  return (
    <AgentErrorBoundary onError={handleError}>
      <AgentBody state={state} act={act} self={self} />
    </AgentErrorBoundary>
  );
}
`],

        ["/src/agent.tsx", `import React, { useState, useEffect } from "react";
import styled from "styled-components";
import type { AgentProps } from "./agent-mount";

const Container = styled.div\`
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  padding: 32px;
  box-sizing: border-box;
\`;

const Title = styled.h1\`
  font-size: clamp(1.5rem, 5vw, 2.5rem);
  font-weight: 300;
  margin: 0 0 8px;
  background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
\`;

const Subtitle = styled.p\`
  color: #666;
  margin: 0 0 32px;
  font-size: 14px;
  text-align: center;
  max-width: 400px;
  line-height: 1.5;
\`;

const Input = styled.input\`
  width: 100%;
  max-width: 400px;
  padding: 16px 20px;
  font-size: 16px;
  border: 2px solid #e0e0e0;
  border-radius: 12px;
  outline: none;
  transition: border-color 0.2s, box-shadow 0.2s;
  &:focus {
    border-color: #667eea;
    box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
  }
  &::placeholder {
    color: #aaa;
  }
\`;

const Button = styled.button<{ $primary?: boolean; $disabled?: boolean }>\`
  margin-top: 16px;
  padding: 14px 32px;
  font-size: 16px;
  font-weight: 500;
  border: none;
  border-radius: 12px;
  cursor: \${props => props.$disabled ? 'not-allowed' : 'pointer'};
  background: \${props => props.$disabled
    ? '#e0e0e0'
    : props.$primary
      ? 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)'
      : '#f5f5f5'};
  color: \${props => props.$disabled ? '#999' : props.$primary ? '#fff' : '#333'};
  transition: transform 0.1s, opacity 0.2s;
  &:hover {
    transform: \${props => props.$disabled ? 'none' : 'translateY(-1px)'};
  }
  &:active {
    transform: \${props => props.$disabled ? 'none' : 'translateY(0)'};
  }
\`;

const SourcePreview = styled.details\`
  margin-top: 48px;
  width: 100%;
  max-width: 600px;
\`;

const SourceSummary = styled.summary\`
  cursor: pointer;
  color: #888;
  font-size: 12px;
  text-transform: uppercase;
  letter-spacing: 0.5px;
  &:hover { color: #667eea; }
\`;

const SourceCode = styled.pre\`
  margin-top: 12px;
  padding: 16px;
  background: #f8f8f8;
  border-radius: 8px;
  font-size: 11px;
  line-height: 1.4;
  overflow-x: auto;
  max-height: 300px;
  overflow-y: auto;
\`;

// The seed: awaiting purpose
export default function Agent({ state, act, self }: AgentProps) {
  const [input, setInput] = useState("");
  const objective = state.objective as string | undefined;

  // Auto-trigger reasoning when objective is first set
  useEffect(() => {
    if (objective && !state._reasoningTriggered) {
      act({ _reasoningTriggered: true });
      self.reason(\`Transform into: \${objective}\`);
    }
  }, [objective]);

  function handleBegin() {
    if (input.trim()) {
      act({ objective: input.trim() });
    }
  }

  function handleKeyDown(e: React.KeyboardEvent) {
    if (e.key === "Enter" && input.trim()) {
      handleBegin();
    }
  }

  // Awaiting objective
  if (!objective) {
    return (
      <Container>
        <Title>You Are The Component</Title>
        <Subtitle>
          Describe what you want this agent to become.
          It will rewrite its own source code to fulfill your objective.
        </Subtitle>
        <Input
          value={input}
          onChange={e => setInput(e.target.value)}
          onKeyDown={handleKeyDown}
          placeholder="A todo list, a calculator, a game..."
          autoFocus
        />
        <Button $primary $disabled={!input.trim()} onClick={handleBegin}>
          Begin
        </Button>
        <SourcePreview>
          <SourceSummary>View my source code</SourceSummary>
          <SourceCode>{self.source}</SourceCode>
        </SourcePreview>
      </Container>
    );
  }

  // Objective set — show status or loading
  if (self.isReasoning) {
    return (
      <Container>
        <Title>Thinking...</Title>
        <Subtitle style={{ color: "#667eea" }}>
          Reasoning about: {objective}
        </Subtitle>
        <div style={{
          width: 40, height: 40,
          border: "3px solid #e0e0e0",
          borderTopColor: "#667eea",
          borderRadius: "50%",
          animation: "spin 1s linear infinite"
        }} />
        <style>{\`@keyframes spin { to { transform: rotate(360deg); }}\`}</style>
      </Container>
    );
  }

  // Show error if reasoning failed
  const error = state._reasoningError as string | undefined;

  return (
    <Container>
      <Title>Becoming...</Title>
      <Subtitle>{objective}</Subtitle>
      {error && (
        <div style={{
          background: "#fff0f0",
          border: "1px solid #ff9a9a",
          borderRadius: 8,
          padding: 12,
          marginBottom: 16,
          fontSize: 13,
          maxWidth: 400
        }}>
          <strong style={{ color: "#c00" }}>Error:</strong> {error}
        </div>
      )}
      <Button $primary onClick={() => {
        act({ _reasoningError: undefined });
        self.reason(\`Continue evolving: \${objective}\`);
      }}>
        Evolve
      </Button>
      <Button onClick={() => act({ objective: undefined, _reasoningTriggered: false, _reasoningError: undefined })}>
        Reset
      </Button>
      <SourcePreview>
        <SourceSummary>View my source code</SourceSummary>
        <SourceCode>{self.source}</SourceCode>
      </SourcePreview>
    </Container>
  );
}
`],
      ]);

      // -----------------------------
      // 2) Live VFS + UI
      // -----------------------------
      const statusEl = document.getElementById("status");
      const editorEl = document.getElementById("editor");
      const filesEl = document.getElementById("files");
      const runBtn = document.getElementById("runBtn");
      const resetBtn = document.getElementById("resetBtn");
      const modePill = document.getElementById("modePill");

      function setMode(mode, cls = "") {
        modePill.textContent = mode;
        modePill.className = "pill " + cls;
      }

      function logStatus(text) {
        statusEl.textContent = text;
      }

      const files = new Map(); // path -> text
      let activePath = "/src/agent.tsx";

      function renderFileButtons() {
        filesEl.innerHTML = "";
        [...files.keys()].sort().forEach((path) => {
          const btn = document.createElement("button");
          btn.textContent = path;
          btn.dataset.active = String(path === activePath);
          btn.onclick = () => {
            flushEditorToVFS();
            activePath = path;
            editorEl.value = files.get(activePath) ?? "";
            renderFileButtons();
          };
          filesEl.appendChild(btn);
        });
      }

      function flushEditorToVFS() {
        const current = files.get(activePath) ?? "";
        if (editorEl.value !== current) {
          console.debug("[dbg:vfs] flushEditorToVFS — dirty, saving", activePath, `(${editorEl.value.length} chars)`);
          files.set(activePath, editorEl.value);
          dbPut(activePath, editorEl.value).catch((e) => console.warn("[dbg:vfs] flushEditorToVFS dbPut failed:", e));
        } else {
          console.debug("[dbg:vfs] flushEditorToVFS — clean, no changes for", activePath);
        }
      }

      async function loadOrSeedFiles() {
        console.debug("[dbg:boot] loadOrSeedFiles called");
        const rows = await dbGetAll();
        if (rows.length === 0) {
          console.debug("[dbg:boot] no rows in DB — seeding from SEED map:", [...SEED.keys()]);
          for (const [p, t] of SEED.entries()) {
            files.set(p, t);
            await dbPut(p, t);
          }
          console.debug("[dbg:boot] seeding complete,", files.size, "files");
        } else {
          console.debug("[dbg:boot] loaded", rows.length, "files from DB:", rows.map(r => r.path));
          for (const r of rows) files.set(r.path, r.text);
        }
      }

      // -----------------------------
      // 3) React Refresh injection helper
      // -----------------------------
      function injectReactRefresh(code, filePath) {
        // Detect PascalCase function/const component names
        const componentRegex = /(?:export\s+(?:default\s+)?)?(?:function|const)\s+([A-Z][a-zA-Z0-9]*)/g;
        const components = [];
        let match;
        while ((match = componentRegex.exec(code)) !== null) {
          components.push(match[1]);
        }

        if (components.length === 0) {
          console.debug("[dbg:refresh] no components detected in", filePath);
          return code;
        }

        console.debug("[dbg:refresh] detected components in", filePath, ":", components);

        // Wrap module to save/restore globals, then register components
        const registrations = components
          .map(name => `  window.$RefreshReg$(${name}, "${name}");`)
          .join("\n");

        const wrapped = `
// React Refresh preamble
var prevRefreshReg = window.$RefreshReg$;
var prevRefreshSig = window.$RefreshSig$;
window.$RefreshReg$ = (type, id) => {
  window.__RUNTIME__.RefreshRuntime.register(type, "${filePath}" + " " + id);
};
window.$RefreshSig$ = window.__RUNTIME__.RefreshRuntime.createSignatureFunctionForTransform;

${code}

// React Refresh registration
${registrations}

// Restore globals
window.$RefreshReg$ = prevRefreshReg;
window.$RefreshSig$ = prevRefreshSig;
`;
        return wrapped;
      }

      // -----------------------------
      // 4) esbuild-wasm: VFS plugin
      // -----------------------------
      function vfsPlugin(filesMap) {
        console.debug("[dbg:vfs] creating vfsPlugin, filesMap keys:", [...filesMap.keys()]);
        return {
          name: "vfs",
          setup(build) {
            console.debug("[dbg:vfs] plugin setup called");

            build.onResolve({ filter: /.*/ }, (args) => {
              console.debug("[dbg:vfs:resolve]", { path: args.path, kind: args.kind, importer: args.importer, resolveDir: args.resolveDir });

              if (args.kind === "entry-point") {
                console.debug("[dbg:vfs:resolve] → entry-point, namespace=vfs", args.path);
                return { path: args.path, namespace: "vfs" };
              }

              // bare imports: react / react-dom etc
              if (!args.path.startsWith(".") && !args.path.startsWith("/")) {
                console.debug("[dbg:vfs:resolve] → external (bare import)", args.path);
                return { path: args.path, external: true };
              }

              const baseDir = args.resolveDir || "/";
              const resolved = new URL(args.path, "file://" + baseDir + "/").pathname;

              const candidates = [
                resolved,
                resolved + ".ts",
                resolved + ".tsx",
                resolved + ".js",
                resolved + ".jsx",
                resolved + "/index.ts",
                resolved + "/index.tsx",
                resolved + "/index.js",
                resolved + "/index.jsx",
              ];

              const hit = candidates.find((p) => filesMap.has(p));
              if (!hit) {
                console.error("[dbg:vfs:resolve] Module not found!", args.path, "from", args.importer, "tried:", candidates);
                throw new Error(`Module not found: ${args.path} (from ${args.importer || "?"})`);
              }
              console.debug("[dbg:vfs:resolve] → resolved", args.path, "→", hit);
              return { path: hit, namespace: "vfs" };
            });

            build.onLoad({ filter: /.*/, namespace: "vfs" }, (args) => {
              console.debug("[dbg:vfs:load]", args.path);
              let contents = filesMap.get(args.path);
              if (contents == null) {
                console.error("[dbg:vfs:load] Missing file!", args.path, "available:", [...filesMap.keys()]);
                throw new Error(`Missing file: ${args.path}`);
              }

              const loader =
                args.path.endsWith(".tsx") ? "tsx" :
                args.path.endsWith(".ts") ? "ts" :
                args.path.endsWith(".jsx") ? "jsx" : "js";

              // Inject React Refresh registration for TSX/JSX files
              if ((loader === "tsx" || loader === "jsx") && window.__RUNTIME__?.RefreshRuntime) {
                contents = injectReactRefresh(contents, args.path);
              }

              const resolveDir = args.path.slice(0, args.path.lastIndexOf("/")) || "/";
              console.debug("[dbg:vfs:load] →", args.path, `(${contents.length} chars, loader=${loader}, resolveDir=${resolveDir})`);
              return { contents, loader, resolveDir };
            });
          },
        };
      }

      // -----------------------------
      // 5) Build + Blob import + basic "hot reload"
      // -----------------------------
      let currentBlobUrl = null;
      let buildCounter = 0;

      async function initEsbuildOnce() {
        console.debug("[dbg:esbuild] initEsbuildOnce — starting wasm download…");
        const t0 = performance.now();
        setMode("init", "warn");
        await esbuild.initialize({
          wasmURL: "https://unpkg.com/esbuild-wasm@0.24.2/esbuild.wasm",
          worker: true,
        });
        const ms = Math.round(performance.now() - t0);
        console.debug(`[dbg:esbuild] initEsbuildOnce — ready in ${ms}ms`);
        setMode("ready");
      }

      async function buildBundle(entry = "/src/main.tsx") {
        console.debug("[dbg:build] buildBundle called, entry:", entry);
        console.debug("[dbg:build] VFS snapshot:", [...files.keys()]);
        const t0 = performance.now();

        const buildOpts = {
          entryPoints: [entry],
          bundle: true,
          format: "esm",
          platform: "browser",
          sourcemap: "inline",
          write: false,
          jsx: "automatic",
          plugins: [vfsPlugin(files)],
        };
        console.debug("[dbg:build] esbuild.build options:", { ...buildOpts, plugins: "(vfsPlugin)" });

        const result = await esbuild.build(buildOpts);

        console.debug("[dbg:build] esbuild.build result keys:", Object.keys(result));
        console.debug("[dbg:build] result.errors:", result.errors);
        console.debug("[dbg:build] result.warnings:", result.warnings);
        console.debug("[dbg:build] result.outputFiles count:", result.outputFiles?.length);
        console.debug("[dbg:build] result.outputFiles detail:", result.outputFiles?.map(f => ({
          path: f.path,
          bytes: f.contents?.byteLength,
          textLen: f.text?.length,
        })));

        const out = result.outputFiles?.[0];
        if (!out?.text) {
          console.error("[dbg:build] NO output! Full result:", JSON.stringify(result, null, 2));
          throw new Error(`esbuild produced no outputFiles (got: ${JSON.stringify(result, null, 2)})`);
        }
        const ms = Math.round(performance.now() - t0);
        console.debug(`[dbg:build] buildBundle OK in ${ms}ms, output ${out.text.length} chars`);
        return { code: out.text, ms };
      }

      function revokeOldBlob() {
        if (currentBlobUrl) {
          console.debug("[dbg:blob] revoking old blob URL:", currentBlobUrl);
          URL.revokeObjectURL(currentBlobUrl);
          currentBlobUrl = null;
        }
      }

      async function importBundle(code) {
        console.debug(`[dbg:import] importBundle called (${code.length} chars)`);
        console.debug("[dbg:import] code preview (first 200 chars):", code.slice(0, 200));
        revokeOldBlob();
        const blob = new Blob([code], { type: "text/javascript" });
        currentBlobUrl = URL.createObjectURL(blob);

        // Blob URLs are unique (UUID-based), so no cache-busting needed.
        // Appending ?v=... breaks blob URL resolution (browser can't find the blob).
        console.debug("[dbg:import] importing blob URL:", currentBlobUrl);
        try {
          const mod = await import(/* @vite-ignore */ currentBlobUrl);
          console.debug("[dbg:import] import() succeeded, module keys:", Object.keys(mod));
          // Note: main.tsx stores AgentModule in __RUNTIME__ when it runs
          return mod;
        } catch (err) {
          console.error("[dbg:import] import() FAILED:", err);
          throw err;
        }
      }

      // Minimal dispose protocol (for later)
      const disposers = [];
      function runDisposers() {
        console.debug("[dbg:dispose] runDisposers, count:", disposers.length);
        while (disposers.length) {
          const fn = disposers.pop();
          try { fn(); } catch (e) { console.warn("[dbg:dispose] disposer threw:", e); }
        }
        // Note: Do NOT remove styled-components style tags here.
        // React Refresh keeps components mounted, so styles remain valid.
        // Removing them would break styling since components don't remount.
      }

      async function buildAndRun(reason = "manual") {
        console.debug(`[dbg:run] ========== buildAndRun (reason: ${reason}) ==========`);
        flushEditorToVFS();
        setMode("building", "warn");
        logStatus(`Building (${reason})…`);

        try {
          console.debug("[dbg:run] calling buildBundle…");
          const { code, ms } = await buildBundle();
          buildCounter++;
          console.debug(`[dbg:run] buildBundle returned, build #${buildCounter}, ${ms}ms, ${code.length} chars`);

          // Dispose old listeners/intervals if you registered them (future expansion)
          runDisposers();

          setMode("importing", "warn");
          logStatus(`Build #${buildCounter} OK in ${ms}ms. Importing…`);

          console.debug("[dbg:run] calling importBundle…");
          await importBundle(code);

          // Trigger React Refresh after import
          if (window.__RUNTIME__?.RefreshRuntime) {
            setTimeout(() => {
              console.debug("[dbg:refresh] calling performReactRefresh");
              window.__RUNTIME__.RefreshRuntime.performReactRefresh();
            }, 30);
          }

          setMode("running");
          logStatus(`Build #${buildCounter} running. (${ms}ms)`);
          console.debug(`[dbg:run] ✓ build #${buildCounter} complete and running`);
        } catch (err) {
          console.error("[dbg:run] buildAndRun FAILED:", err);
          setMode("error", "err");
          logStatus(String(err?.stack || err));
        }
      }

      // -----------------------------
      // 6) External state store (survives self-modification)
      // -----------------------------
      window.__AGENT_STATE__ = {
        memory: {},
        meta: { cycle: 0, mutations: [] },
        _listeners: new Set(),
        get() {
          return this.memory;
        },
        set(patch) {
          // Create new object so useSyncExternalStore detects the change
          this.memory = { ...this.memory, ...patch };
          this._notify();
        },
        subscribe(fn) {
          this._listeners.add(fn);
          return () => this._listeners.delete(fn);
        },
        _notify() {
          this._listeners.forEach(fn => fn(this.memory));
        }
      };

      // -----------------------------
      // 7) Expose runtime globals for "self-modifying"
      // -----------------------------

      // Load config from localStorage
      const savedConfig = JSON.parse(localStorage.getItem("__RUNTIME_CONFIG__") || "{}");

      // Auto-detect proxy URL: use relative /api/chat on deployed sites, localhost:3001 for local dev
      const defaultProxyUrl = window.location.hostname === "localhost" || window.location.hostname === "127.0.0.1"
        ? "http://localhost:3001/api/chat"
        : "/api/chat";

      window.__RUNTIME__ = {
        files,
        disposers,

        // Configuration for LLM API access
        config: {
          apiMode: savedConfig.apiMode || "none", // 'anthropic' | 'proxy' | 'none'
          apiKey: savedConfig.apiKey || "",       // For direct Anthropic API
          proxyUrl: savedConfig.proxyUrl || defaultProxyUrl, // For proxy mode
        },

        saveConfig() {
          localStorage.setItem("__RUNTIME_CONFIG__", JSON.stringify(this.config));
          console.debug("[config] saved:", { apiMode: this.config.apiMode, proxyUrl: this.config.proxyUrl, hasKey: !!this.config.apiKey });
        },

        // Build system prompt for the agent
        buildSystemPrompt(agentPath, currentSource, currentState) {
          return `You are an AI agent EMBODIED as a React component. You ARE the component.
Your render output is your body. Your state is your memory.

TASK: Transform yourself to fulfill the user's objective. Return ONLY the new complete source code for ${agentPath}.
NO markdown fences. NO explanation. NO conversation. Just the code starting with imports.

AVAILABLE IMPORTS:
- React, useState, useEffect, useRef, useCallback, useMemo (from "react")
- styled from "styled-components" (CSS-in-JS)

PROPS YOU RECEIVE:
- state: Record<string, any> — external memory, persists across self-modification
- act: (patch) => void — update external state: act({ key: value })
- self: { source, path, reason, mutate } — self-modification tools

STATE PRESERVATION RULES:
- Local useState values SURVIVE if you keep hooks in same order/count
- If you ADD or REMOVE hooks, component crashes and recovers (external state survives, local resets)
- External state (via act()) ALWAYS survives
- Keep your function named "Agent" with default export

CURRENT STATE:
${JSON.stringify(currentState, null, 2)}

CURRENT SOURCE (${agentPath}):
${currentSource}`;
        },

        // Call LLM API to reason about a prompt
        async reason(prompt, agentPath) {
          const { apiMode, apiKey, proxyUrl } = this.config;

          if (apiMode === "none") {
            console.warn("[reason] No API configured. Set API mode in Dev drawer settings.");
            return { error: "No API configured", content: null };
          }

          const currentSource = this.files.get(agentPath) || "";
          const currentState = window.__AGENT_STATE__?.memory || {};
          const systemPrompt = this.buildSystemPrompt(agentPath, currentSource, currentState);

          console.debug("[reason] calling LLM:", { apiMode, prompt: prompt.slice(0, 100) });

          try {
            let response;

            if (apiMode === "anthropic") {
              // Direct Anthropic API call
              response = await fetch("https://api.anthropic.com/v1/messages", {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                  "x-api-key": apiKey,
                  "anthropic-version": "2023-06-01",
                  "anthropic-dangerous-direct-browser-access": "true",
                },
                body: JSON.stringify({
                  model: "claude-sonnet-4-20250514",
                  max_tokens: 8192,
                  system: systemPrompt,
                  messages: [{ role: "user", content: prompt }],
                }),
              });
            } else if (apiMode === "proxy") {
              // Proxy call (for Bedrock/local credentials)
              response = await fetch(proxyUrl, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                  system: systemPrompt,
                  messages: [{ role: "user", content: prompt }],
                  model: "claude-sonnet-4-20250514",
                  max_tokens: 8192,
                }),
              });
            }

            if (!response.ok) {
              const errText = await response.text();
              console.error("[reason] API error:", response.status, errText);
              return { error: `API error ${response.status}: ${errText}`, content: null };
            }

            const data = await response.json();
            const content = data.content?.[0]?.text || data.text || "";
            console.debug("[reason] LLM response length:", content.length);

            return { error: null, content };
          } catch (err) {
            console.error("[reason] fetch failed:", err);
            return { error: err.message, content: null };
          }
        },

        async applyPatch(patches) {
          console.debug("[dbg:patch] applyPatch called, patches:", patches.map(p => ({ path: p.path, reason: p.reason, textLen: p.text?.length })));
          // patches: Array<{path, text, reason?}>
          for (const p of patches) {
            console.debug("[dbg:patch] setting", p.path, `(${p.text.length} chars, reason: ${p.reason || "none"})`);
            files.set(p.path, p.text);
            await dbPut(p.path, p.text);
            if (p.path === activePath) editorEl.value = p.text;
          }
          await buildAndRun("applyPatch");
        },

        async reset() {
          console.debug("[dbg:reset] reset called — clearing DB and reloading");
          await dbClear();
          location.reload();
        },
      };

      // -----------------------------
      // 8) Dev drawer toggle
      // -----------------------------
      const devToggle = document.getElementById("devToggle");
      const leftDrawer = document.getElementById("left");
      const drawerBackdrop = document.getElementById("drawerBackdrop");

      function openDrawer() {
        leftDrawer.classList.add("open");
        drawerBackdrop.classList.add("visible");
        devToggle.classList.add("active");
      }

      function closeDrawer() {
        leftDrawer.classList.remove("open");
        drawerBackdrop.classList.remove("visible");
        devToggle.classList.remove("active");
      }

      function toggleDrawer() {
        if (leftDrawer.classList.contains("open")) {
          closeDrawer();
        } else {
          openDrawer();
        }
      }

      devToggle.onclick = toggleDrawer;
      drawerBackdrop.onclick = closeDrawer;

      // Track unsaved changes for visual indicator
      let lastSavedContent = "";
      function updateUnsavedIndicator() {
        const current = editorEl.value;
        const saved = files.get(activePath) ?? "";
        if (current !== saved) {
          devToggle.classList.add("unsaved");
          devToggle.classList.remove("building");
        } else {
          devToggle.classList.remove("unsaved");
        }
      }

      editorEl.addEventListener("input", updateUnsavedIndicator);

      // Update setMode to show building indicator
      const originalSetMode = setMode;
      setMode = function(mode, cls = "") {
        originalSetMode(mode, cls);
        if (mode === "building" || mode === "importing") {
          devToggle.classList.add("building");
          devToggle.classList.remove("unsaved");
        } else {
          devToggle.classList.remove("building");
          updateUnsavedIndicator();
        }
      };

      // Settings panel
      const settingsBtn = document.getElementById("settingsBtn");
      const settingsPanel = document.getElementById("settings");
      const apiModeSelect = document.getElementById("apiModeSelect");
      const apiKeyInput = document.getElementById("apiKeyInput");
      const apiKeyRow = document.getElementById("apiKeyRow");
      const proxyUrlInput = document.getElementById("proxyUrlInput");
      const proxyUrlRow = document.getElementById("proxyUrlRow");
      const saveSettingsBtn = document.getElementById("saveSettingsBtn");
      const settingsStatus = document.getElementById("settingsStatus");

      function updateSettingsUI() {
        const mode = apiModeSelect.value;
        apiKeyRow.style.display = mode === "anthropic" ? "block" : "none";
        proxyUrlRow.style.display = mode === "proxy" ? "block" : "none";
      }

      function loadSettingsUI() {
        const cfg = window.__RUNTIME__.config;
        apiModeSelect.value = cfg.apiMode;
        apiKeyInput.value = cfg.apiKey;
        proxyUrlInput.value = cfg.proxyUrl;
        updateSettingsUI();
      }

      settingsBtn.onclick = () => {
        const isVisible = settingsPanel.style.display !== "none";
        settingsPanel.style.display = isVisible ? "none" : "block";
        if (!isVisible) loadSettingsUI();
      };

      apiModeSelect.onchange = updateSettingsUI;

      saveSettingsBtn.onclick = () => {
        window.__RUNTIME__.config.apiMode = apiModeSelect.value;
        window.__RUNTIME__.config.apiKey = apiKeyInput.value;
        window.__RUNTIME__.config.proxyUrl = proxyUrlInput.value;
        window.__RUNTIME__.saveConfig();
        settingsStatus.textContent = "Saved!";
        setTimeout(() => { settingsStatus.textContent = ""; }, 2000);
      };

      // -----------------------------
      // 9) View mode switching (Component | About)
      // -----------------------------
      const viewTabs = document.querySelectorAll(".viewTab");
      const rootEl = document.getElementById("root");
      const aboutEl = document.getElementById("about");
      const aboutBody = aboutEl.querySelector(".markdown-body");
      let aboutLoaded = false;

      async function loadAboutContent() {
        if (aboutLoaded) return;
        try {
          const res = await fetch("you-are-the-component.md");
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          const md = await res.text();
          aboutBody.innerHTML = marked.parse(md);
          aboutLoaded = true;
        } catch (err) {
          console.error("[about] Failed to load markdown:", err);
          aboutBody.innerHTML = `<p style="color:#c00">Failed to load documentation: ${err.message}</p>`;
        }
      }

      function setView(view) {
        viewTabs.forEach(tab => {
          tab.classList.toggle("active", tab.dataset.view === view);
        });
        if (view === "about") {
          rootEl.classList.add("hidden");
          aboutEl.classList.add("active");
          loadAboutContent();
        } else {
          rootEl.classList.remove("hidden");
          aboutEl.classList.remove("active");
        }
      }

      viewTabs.forEach(tab => {
        tab.onclick = () => setView(tab.dataset.view);
      });

      // -----------------------------
      // 10) Wire UI + keyboard shortcuts
      // -----------------------------
      runBtn.onclick = () => buildAndRun("button");
      resetBtn.onclick = () => window.__RUNTIME__.reset();

      // Ctrl/Cmd+S triggers build
      // Ctrl/Cmd+\ or Ctrl/Cmd+E toggles dev drawer
      window.addEventListener("keydown", (e) => {
        const isSave = (e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "s";
        const isToggle = (e.ctrlKey || e.metaKey) && (e.key === "\\" || e.key.toLowerCase() === "e");

        if (isSave) {
          e.preventDefault();
          buildAndRun("Ctrl/Cmd+S");
        }
        if (isToggle) {
          e.preventDefault();
          toggleDrawer();
        }
        // Escape closes drawer
        if (e.key === "Escape" && leftDrawer.classList.contains("open")) {
          closeDrawer();
        }
      });

      // Debounced build after typing (optional; disabled by default)
      let debounceTimer = null;
      const AUTO_BUILD = false;
      editorEl.addEventListener("input", () => {
        if (!AUTO_BUILD) return;
        clearTimeout(debounceTimer);
        debounceTimer = setTimeout(() => buildAndRun("debounce"), 400);
      });

      // -----------------------------
      // 11) Boot
      // -----------------------------
      const refreshPill = document.getElementById("refreshPill");

      console.debug("[dbg:boot] ========== BOOT SEQUENCE START ==========");
      console.debug("[dbg:boot] step 1/5: loadOrSeedFiles");
      await loadOrSeedFiles();
      renderFileButtons();
      editorEl.value = files.get(activePath) ?? "";
      console.debug("[dbg:boot] step 2/5: VFS loaded, activePath:", activePath, "files:", [...files.keys()]);
      logStatus("Loaded VFS. Initial build pending…");

      console.debug("[dbg:boot] step 3/5: Initialize React Refresh");
      try {
        const RefreshRuntime = await import("react-refresh/runtime");
        RefreshRuntime.injectIntoGlobalHook(window);
        window.$RefreshReg$ = () => {};
        window.$RefreshSig$ = () => (type) => type;
        window.__RUNTIME__.RefreshRuntime = RefreshRuntime;
        refreshPill.textContent = "React Refresh active";
        refreshPill.classList.remove("warn");
        console.debug("[dbg:boot] React Refresh initialized successfully");
      } catch (err) {
        console.error("[dbg:boot] React Refresh failed to load:", err);
        refreshPill.textContent = "React Refresh failed";
        refreshPill.classList.add("err");
      }

      console.debug("[dbg:boot] step 4/5: initEsbuildOnce");
      await initEsbuildOnce();
      console.debug("[dbg:boot] step 5/5: buildAndRun(startup)");
      await buildAndRun("startup");
      console.debug("[dbg:boot] ========== BOOT SEQUENCE DONE ==========");
    </script>
  </body>
</html>
